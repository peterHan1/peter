{"version":3,"sources":["webpack:///src/pages/item-pic/item-pic.min.js","webpack:///webpack/bootstrap d952d7c1de0e6ff23822","webpack:///./src/pages/item-pic/item-pic.js","webpack:////Users/qiyuan/.spon/mobi/fecomponent/mobi-hammer/0.0.1/index.js","webpack:////Users/qiyuan/.spon/mobi/fecomponent/mobi-detect-ua/0.0.4/index.js","webpack:////Users/qiyuan/.spon/mobi/fecomponent/mobi-jswebview/0.0.17/index.js","webpack:////Users/qiyuan/.spon/mobi/fecomponent/mobi-zepto-callbacks/0.0.4/index.js","webpack:////Users/qiyuan/.spon/mobi/fecomponent/mobi-zepto-deferred/0.0.3/index.js","webpack:////Users/qiyuan/.spon/mobi/fecomponent/mobi-jswebview/0.0.17/js-debug.less?db7a","webpack:////Users/qiyuan/.spon/mobi/fecomponent/mobi-jswebview/0.0.17/js-debug.less","webpack:////usr/local/lib/~/spon/~/css-loader/lib/css-base.js","webpack:////usr/local/lib/~/spon/~/style-loader/addStyles.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","Hammer","globalConfig","$","Browser","versions","showjoyShopiOs","showjoyShopAndroid","on","imgIndex","this","index","JSBridge","callHandler","stateMap","scale","position","x","y","transform","setTransform","arr","split","i","length","search","match","showBox","ev","target","nodeName","show","src","find","attr","hideWrap","preventDefault","hide","css","-webkit-transform","scaleImg","scaleEndImg","moveImg","parseFloat","deltaX","deltaY","moveEndImg","wrap","wrapHammer","singletap","Tap","doubletap","event","taps","pinch","Pinch","pan","Pan","add","requireFailure","img","imgHammer","setTimeoutContext","fn","timeout","context","setTimeout","bindFn","invokeArrayArg","arg","Array","isArray","each","obj","iterator","forEach","undefined","hasOwnProperty","extend","dest","merge","keys","Object","inherit","child","base","properties","childP","baseP","prototype","create","constructor","_super","apply","arguments","boolOrFn","val","args","TYPE_FUNCTION","ifUndefined","val1","val2","addEventListeners","types","handler","splitStr","type","addEventListener","removeEventListeners","removeEventListener","hasParent","node","parent","parentNode","inStr","str","indexOf","trim","inArray","findByKey","toArray","slice","uniqueArray","key","sort","results","values","push","a","b","prefixed","property","prefix","prop","camelProp","toUpperCase","VENDOR_PREFIXES","uniqueId","_uniqueId","getWindowForElement","element","doc","ownerDocument","defaultView","parentWindow","Input","manager","callback","self","options","inputTarget","domHandler","enable","init","createInputInstance","Type","inputClass","SUPPORT_POINTER_EVENTS","PointerEventInput","SUPPORT_ONLY_TOUCH","TouchInput","SUPPORT_TOUCH","TouchMouseInput","MouseInput","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","INPUT_START","isFinal","INPUT_END","INPUT_CANCEL","session","computeInputData","emit","recognize","prevInput","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","timeStamp","now","deltaTime","angle","getAngle","distance","getDistance","computeDeltaXY","offsetDirection","getDirection","getScale","rotation","getRotation","computeIntervalInputData","srcEvent","offset","offsetDelta","prevDelta","velocity","velocityX","velocityY","direction","last","lastInterval","COMPUTE_INTERVAL","v","getVelocity","abs","clientX","round","clientY","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","p1","p2","props","PROPS_XY","Math","sqrt","atan2","PI","start","end","PROPS_CLIENT_XY","evEl","MOUSE_ELEMENT_EVENTS","evWin","MOUSE_WINDOW_EVENTS","allow","pressed","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","store","pointerEvents","SingleTouchInput","evTarget","SINGLE_TOUCH_TARGET_EVENTS","SINGLE_TOUCH_WINDOW_EVENTS","started","normalizeSingleTouches","all","touches","changed","changedTouches","concat","TOUCH_TARGET_EVENTS","targetIds","getTouches","allTouches","INPUT_MOVE","identifier","targetTouches","changedTargetTouches","filter","touch","mouse","TouchAction","value","set","cleanTouchActions","actions","TOUCH_ACTION_NONE","hasPanX","TOUCH_ACTION_PAN_X","hasPanY","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_AUTO","Recognizer","defaults","state","STATE_POSSIBLE","simultaneous","requireFail","stateStr","STATE_CANCELLED","STATE_ENDED","STATE_CHANGED","STATE_BEGAN","directionStr","getRecognizerByNameIfManager","otherRecognizer","recognizer","get","AttrRecognizer","PanRecognizer","pX","pY","PinchRecognizer","PressRecognizer","_timer","_input","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","recognizers","preset","Manager","handlers","touchAction","toggleCssProps","item","recognizeWith","cssProps","name","style","triggerDomEvent","data","gestureEvent","document","createEvent","initEvent","gesture","dispatchEvent","TEST_ELEMENT","createElement","Date","MOBILE_REGEX","window","test","navigator","userAgent","INPUT_TYPE_TOUCH","INPUT_TYPE_PEN","INPUT_TYPE_MOUSE","INPUT_TYPE_KINECT","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","destroy","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","button","which","pointerType","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","2","3","4","5","MSPointerEvent","removePointer","eventTypeNormalized","toLowerCase","replace","isTouch","storeIndex","pointerId","splice","SINGLE_TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TOUCH_INPUT_MAP","inputEvent","inputData","isMouse","PREFIXED_TOUCH_ACTION","NATIVE_TOUCH_ACTION","TOUCH_ACTION_COMPUTE","compute","update","getTouchAction","join","preventDefaults","prevented","hasNone","preventSrc","STATE_RECOGNIZED","STATE_FAILED","dropRecognizeWith","dropRequireFailure","hasRequireFailures","canRecognizeWith","withState","tryEmit","canEmit","inputDataClone","process","reset","attrTest","optionPointers","isRecognized","isValid","threshold","directionTest","hasMoved","inOut","time","validPointers","validMovement","validTime","clearTimeout","interval","posThreshold","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","VERSION","domEvents","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","STOP","FORCED_STOP","stop","force","stopped","curRecognizer","existing","remove","events","off","Swipe","Rotate","Press","u","appVersion","webKit","mobile","ios","android","iPhone","iPad","webApp","weixin","showjoyiOS","showjoyAndroid","iOSAPP","androidAPP","language","browserLanguage","Env","hostname","location","isAndroid","isiOS","_jsBridge","retFromNative","cbsAfterExecNativeMethod","messagingIframe","_createQueueReadyIframe","schema","display","documentElement","appendChild","_init","def","Deferred","resolve","promise","WebViewJavascriptBridge","registerHandler","methodName","method","ret","_this","_isDebug","_debugOutPut","_debugStyle","_NORMAL_","then","bridge","message","responseCallback","JSON","stringify","javaObj","params","isFunction","jsObj","_ERROR_","TypeError","e","console","log","executeNativeMethod","className","cb","EvalError","toString","fnCode","len","eval","registerJSMethod","isiOS4JSC","_JSMethod","encodeURIComponent","_transResultFromNative","cbs","_isTest","setDebug","bool","_debugShow","_debugBlockInit","debugBlock","append","_eventBind","$webviewConsole","hasClass","removeClass","addClass","_initDebugFunction","_WARNING_","content","$consolePannel","Callbacks","memory","fired","firing","firingStart","firingLength","firingIndex","list","stack","once","fire","stopOnFalse","shift","disable","_","unique","has","empty","disabled","lock","locked","fireWith","func","tuples","always","deferred","done","fail","fns","defer","tuple","returned","reject","progress","notify","stateString","when","sub","progressValues","progressContexts","resolveContexts","resolveValues","remain","updateFn","ctx","notifyWith","resolveWith","locals","result","mediaQuery","alreadyImportedModules","addStylesToDom","styles","domStyle","stylesInDom","refs","j","parts","addStyle","listToStyles","newStyles","media","sourceMap","part","insertStyleElement","styleElement","head","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","nextSibling","insertBefore","firstChild","Error","removeStyleElement","removeChild","idx","createStyleElement","createLinkElement","linkElement","rel","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","bind","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","href","applyToTag","newObj","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","setAttribute","unescape","blob","oldSrc","memoize","memo","isOldIE","getElementsByTagName","newList","mayRemove","textStore","replacement","Boolean"],"mappings":"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","file":"src/pages/item-pic/item-pic.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Hammer = __webpack_require__(1);\n\tvar globalConfig = __webpack_require__(2);\n\t__webpack_require__(3);\n\t\n\t$(function () {\n\t  if(globalConfig.Browser.versions.showjoyShopiOs || globalConfig.Browser.versions.showjoyShopAndroid) {\n\t    $('.j_ItemPic').on('click', function() {\n\t      var imgIndex = $(this).index();\n\t      $.JSBridge.callHandler('shopc_show_imgLists', {\n\t        index: imgIndex\n\t      }, function () { });\n\t    });\n\t  } else {\n\t    var stateMap = {\n\t      scale: 1,\n\t      position: {\n\t        x: 0,\n\t        y: 0\n\t      }\n\t    };\n\t\n\t    var transform = '';\n\t\n\t    var setTransform = function () {\n\t      var arr = transform.split(/\\)\\s/);\n\t      for (var i = 0; i < arr.length; i++) {\n\t        if (arr[i].search(/scale/) !== -1) {\n\t          stateMap.scale = arr[i].match(/\\d+(\\.\\d+)?/)[0];\n\t        } else if (arr[i].search(/translate/) !== -1) {\n\t          stateMap.position.x = arr[i].match(/\\-?\\d+px/g)[0].match(/\\-?\\d+/);\n\t          stateMap.position.y = arr[i].match(/\\-?\\d+px/g)[1].match(/\\-?\\d+/);\n\t        }\n\t      }\n\t    }\n\t    var showBox = function (ev) {\n\t      if (ev.target.nodeName === 'IMG') {\n\t        $('.j_BoxDescriptionImg').show();\n\t        var src = ev.target.src;\n\t        $('.j_BoxDescriptionImg').find('img').attr('src', src);\n\t      }\n\t    }\n\t    var hideWrap = function (ev) {\n\t      ev.preventDefault();\n\t      $('.j_BoxDescriptionImg').hide();\n\t      $('.j_Img').css({\n\t        '-webkit-transform': 'scale(1)',\n\t        'transform': 'scale(1)'\n\t      });\n\t      stateMap.scale = 1;\n\t      stateMap.position.x = 0;\n\t      stateMap.position.y = 0;\n\t    };\n\t    var scaleImg = function (ev) {\n\t      $('.j_Img').css({\n\t        '-webkit-transform': 'scale(' + (stateMap.scale * ev.scale) + ')' + '  translate3d(' + \n\t          (stateMap.position.x) + 'px,' + (stateMap.position.y) + 'px, 0px)',\n\t        'transform': 'scale(' + (stateMap.scale * ev.scale) + ')' + '  translate3d(' + \n\t          (stateMap.position.x) + 'px,' + (stateMap.position.y) + 'px, 0px)'\n\t      });\n\t    }\n\t    var scaleEndImg = function () {\n\t      transform = $('.j_Img').css('-webkit-transform') === \n\t        null ? ('.j_Img').css('-webkit-transform') : $('.j_Img').css('-webkit-transform');\n\t      setTransform();\n\t      if (stateMap.scale < 1) {\n\t        $('.j_Img').css({\n\t          '-webkit-transform': 'scale(1)',\n\t          'transform': 'scale(1)'\n\t        });\n\t        stateMap.scale = 1;\n\t        stateMap.position.x = 0;\n\t        stateMap.position.y = 0;\n\t      }\n\t    };\n\t\n\t    var moveImg = function (ev) {\n\t      if (stateMap.scale > 1) {\n\t        $('.j_Img').css({\n\t          '-webkit-transform': 'scale(' + (stateMap.scale) + ')' + ' translate3d(' + \n\t            parseFloat(parseFloat(stateMap.position.x) + parseFloat(ev.deltaX)) + 'px,' + \n\t            parseFloat(parseFloat(stateMap.position.y) + parseFloat(ev.deltaY)) + 'px, 0px)',\n\t          'transform': 'scale(' + (stateMap.scale) + ')' + ' translate3d(' + \n\t            parseFloat(parseFloat(stateMap.position.x) + parseFloat(ev.deltaX)) + 'px,' + \n\t            parseFloat(parseFloat(stateMap.position.y) + parseFloat(ev.deltaY)) + 'px, 0px)'\n\t        });\n\t      }\n\t    }\n\t    var moveEndImg = function () {\n\t      transform = $('.j_Img').css('-webkit-transform') === \n\t        null ? ('.j_Img').css('-webkit-transform') : $('.j_Img').css('-webkit-transform');\n\t      setTransform();\n\t    };\n\t    var wrap = $('.j_BoxDescriptionImg')[0];\n\t    var wrapHammer = new Hammer(wrap);\n\t    var singletap = new Hammer.Tap();\n\t    var doubletap = new Hammer.Tap({ event: 'doubletap', taps: 2 });\n\t    var pinch = new Hammer.Pinch();\n\t    var pan = new Hammer.Pan();\n\t\n\t    wrapHammer.add(singletap);\n\t    wrapHammer.add(doubletap);\n\t    singletap.requireFailure(doubletap);\n\t    doubletap.requireFailure(singletap);\n\t    wrapHammer.add(pinch);\n\t    wrapHammer.add(pan);\n\t\n\t    wrapHammer.on('tap', hideWrap);\n\t    wrapHammer.on('pinchmove', scaleImg);\n\t    wrapHammer.on('pinchend', scaleEndImg);\n\t    wrapHammer.on('panmove', moveImg);\n\t    wrapHammer.on('panend', moveEndImg);\n\t\n\t    var img = $('.j_Box2')[0];\n\t    var imgHammer = new Hammer(img);\n\t    imgHammer.on('tap', showBox);\n\t  }\n\t});\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t//  模块外面不用包一层define，dev和build时工具会自动加上，遵循CommonJS规范，像node一样写就可以了，如下\n\t\n\t'use strict';\n\t\n\t\n\t// 支持在项目文件中使用基于src根目录下的绝对路径\n\t// var Common = require('components/abc/abc');\n\t// 使用 fecomponent 组件\n\t// var say = require('fecomponent/mobi-say');\n\t\n\t/*! Hammer.JS - v2.0.4 - 2014-09-28\n\t * http://hammerjs.github.io/\n\t *\n\t * Copyright (c) 2014 Jorik Tangelder;\n\t * Licensed under the MIT license */ \n\t\n\t\n\t    var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\n\t    var TEST_ELEMENT = document.createElement('div');\n\t\n\t    var TYPE_FUNCTION = 'function';\n\t\n\t    var round = Math.round;\n\t    var abs = Math.abs;\n\t    var now = Date.now;\n\t\n\t    /**\n\t     * set a timeout with a given scope\n\t     * @param {Function} fn\n\t     * @param {Number} timeout\n\t     * @param {Object} context\n\t     * @returns {number}\n\t     */\n\t    function setTimeoutContext(fn, timeout, context) {\n\t        return setTimeout(bindFn(fn, context), timeout);\n\t    }\n\t\n\t    /**\n\t     * if the argument is an array, we want to execute the fn on each entry\n\t     * if it aint an array we don't want to do a thing.\n\t     * this is used by all the methods that accept a single and array argument.\n\t     * @param {*|Array} arg\n\t     * @param {String} fn\n\t     * @param {Object} [context]\n\t     * @returns {Boolean}\n\t     */\n\t    function invokeArrayArg(arg, fn, context) {\n\t        if (Array.isArray(arg)) {\n\t            each(arg, context[fn], context);\n\t            return true;\n\t        }\n\t        return false;\n\t    }\n\t\n\t    /**\n\t     * walk objects and arrays\n\t     * @param {Object} obj\n\t     * @param {Function} iterator\n\t     * @param {Object} context\n\t     */\n\t    function each(obj, iterator, context) {\n\t        var i;\n\t\n\t        if (!obj) {\n\t            return;\n\t        }\n\t\n\t        if (obj.forEach) {\n\t            obj.forEach(iterator, context);\n\t        } else if (obj.length !== undefined) {\n\t            i = 0;\n\t            while (i < obj.length) {\n\t                iterator.call(context, obj[i], i, obj);\n\t                i++;\n\t            }\n\t        } else {\n\t            for (i in obj) {\n\t                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * extend object.\n\t     * means that properties in dest will be overwritten by the ones in src.\n\t     * @param {Object} dest\n\t     * @param {Object} src\n\t     * @param {Boolean} [merge]\n\t     * @returns {Object} dest\n\t     */\n\t    function extend(dest, src, merge) {\n\t        var keys = Object.keys(src);\n\t        var i = 0;\n\t        while (i < keys.length) {\n\t            if (!merge || (merge && dest[keys[i]] === undefined)) {\n\t                dest[keys[i]] = src[keys[i]];\n\t            }\n\t            i++;\n\t        }\n\t        return dest;\n\t    }\n\t\n\t    /**\n\t     * merge the values from src in the dest.\n\t     * means that properties that exist in dest will not be overwritten by src\n\t     * @param {Object} dest\n\t     * @param {Object} src\n\t     * @returns {Object} dest\n\t     */\n\t    function merge(dest, src) {\n\t        return extend(dest, src, true);\n\t    }\n\t\n\t    /**\n\t     * simple class inheritance\n\t     * @param {Function} child\n\t     * @param {Function} base\n\t     * @param {Object} [properties]\n\t     */\n\t    function inherit(child, base, properties) {\n\t        var baseP = base.prototype,\n\t            childP;\n\t\n\t        childP = child.prototype = Object.create(baseP);\n\t        childP.constructor = child;\n\t        childP._super = baseP;\n\t\n\t        if (properties) {\n\t            extend(childP, properties);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * simple function bind\n\t     * @param {Function} fn\n\t     * @param {Object} context\n\t     * @returns {Function}\n\t     */\n\t    function bindFn(fn, context) {\n\t        return function boundFn() {\n\t            return fn.apply(context, arguments);\n\t        };\n\t    }\n\t\n\t    /**\n\t     * let a boolean value also be a function that must return a boolean\n\t     * this first item in args will be used as the context\n\t     * @param {Boolean|Function} val\n\t     * @param {Array} [args]\n\t     * @returns {Boolean}\n\t     */\n\t    function boolOrFn(val, args) {\n\t        if (typeof val == TYPE_FUNCTION) {\n\t            return val.apply(args ? args[0] || undefined : undefined, args);\n\t        }\n\t        return val;\n\t    }\n\t\n\t    /**\n\t     * use the val2 when val1 is undefined\n\t     * @param {*} val1\n\t     * @param {*} val2\n\t     * @returns {*}\n\t     */\n\t    function ifUndefined(val1, val2) {\n\t        return (val1 === undefined) ? val2 : val1;\n\t    }\n\t\n\t    /**\n\t     * addEventListener with multiple events at once\n\t     * @param {EventTarget} target\n\t     * @param {String} types\n\t     * @param {Function} handler\n\t     */\n\t    function addEventListeners(target, types, handler) {\n\t        each(splitStr(types), function(type) {\n\t            target.addEventListener(type, handler, false);\n\t        });\n\t    }\n\t\n\t    /**\n\t     * removeEventListener with multiple events at once\n\t     * @param {EventTarget} target\n\t     * @param {String} types\n\t     * @param {Function} handler\n\t     */\n\t    function removeEventListeners(target, types, handler) {\n\t        each(splitStr(types), function(type) {\n\t            target.removeEventListener(type, handler, false);\n\t        });\n\t    }\n\t\n\t    /**\n\t     * find if a node is in the given parent\n\t     * @method hasParent\n\t     * @param {HTMLElement} node\n\t     * @param {HTMLElement} parent\n\t     * @return {Boolean} found\n\t     */\n\t    function hasParent(node, parent) {\n\t        while (node) {\n\t            if (node == parent) {\n\t                return true;\n\t            }\n\t            node = node.parentNode;\n\t        }\n\t        return false;\n\t    }\n\t\n\t    /**\n\t     * small indexOf wrapper\n\t     * @param {String} str\n\t     * @param {String} find\n\t     * @returns {Boolean} found\n\t     */\n\t    function inStr(str, find) {\n\t        return str.indexOf(find) > -1;\n\t    }\n\t\n\t    /**\n\t     * split string on whitespace\n\t     * @param {String} str\n\t     * @returns {Array} words\n\t     */\n\t    function splitStr(str) {\n\t        return str.trim().split(/\\s+/g);\n\t    }\n\t\n\t    /**\n\t     * find if a array contains the object using indexOf or a simple polyFill\n\t     * @param {Array} src\n\t     * @param {String} find\n\t     * @param {String} [findByKey]\n\t     * @return {Boolean|Number} false when not found, or the index\n\t     */\n\t    function inArray(src, find, findByKey) {\n\t        if (src.indexOf && !findByKey) {\n\t            return src.indexOf(find);\n\t        } else {\n\t            var i = 0;\n\t            while (i < src.length) {\n\t                if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n\t                    return i;\n\t                }\n\t                i++;\n\t            }\n\t            return -1;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * convert array-like objects to real arrays\n\t     * @param {Object} obj\n\t     * @returns {Array}\n\t     */\n\t    function toArray(obj) {\n\t        return Array.prototype.slice.call(obj, 0);\n\t    }\n\t\n\t    /**\n\t     * unique array with objects based on a key (like 'id') or just by the array's value\n\t     * @param {Array} src [{id:1},{id:2},{id:1}]\n\t     * @param {String} [key]\n\t     * @param {Boolean} [sort=False]\n\t     * @returns {Array} [{id:1},{id:2}]\n\t     */\n\t    function uniqueArray(src, key, sort) {\n\t        var results = [];\n\t        var values = [];\n\t        var i = 0;\n\t\n\t        while (i < src.length) {\n\t            var val = key ? src[i][key] : src[i];\n\t            if (inArray(values, val) < 0) {\n\t                results.push(src[i]);\n\t            }\n\t            values[i] = val;\n\t            i++;\n\t        }\n\t\n\t        if (sort) {\n\t            if (!key) {\n\t                results = results.sort();\n\t            } else {\n\t                results = results.sort(function sortUniqueArray(a, b) {\n\t                    return a[key] > b[key];\n\t                });\n\t            }\n\t        }\n\t\n\t        return results;\n\t    }\n\t\n\t    /**\n\t     * get the prefixed property\n\t     * @param {Object} obj\n\t     * @param {String} property\n\t     * @returns {String|Undefined} prefixed\n\t     */\n\t    function prefixed(obj, property) {\n\t        var prefix, prop;\n\t        var camelProp = property[0].toUpperCase() + property.slice(1);\n\t\n\t        var i = 0;\n\t        while (i < VENDOR_PREFIXES.length) {\n\t            prefix = VENDOR_PREFIXES[i];\n\t            prop = (prefix) ? prefix + camelProp : property;\n\t\n\t            if (prop in obj) {\n\t                return prop;\n\t            }\n\t            i++;\n\t        }\n\t        return undefined;\n\t    }\n\t\n\t    /**\n\t     * get a unique id\n\t     * @returns {number} uniqueId\n\t     */\n\t    var _uniqueId = 1;\n\t\n\t    function uniqueId() {\n\t        return _uniqueId++;\n\t    }\n\t\n\t    /**\n\t     * get the window object of an element\n\t     * @param {HTMLElement} element\n\t     * @returns {DocumentView|Window}\n\t     */\n\t    function getWindowForElement(element) {\n\t        var doc = element.ownerDocument;\n\t        return (doc.defaultView || doc.parentWindow);\n\t    }\n\t\n\t    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\t\n\t    var SUPPORT_TOUCH = ('ontouchstart' in window);\n\t    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n\t    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\t\n\t    var INPUT_TYPE_TOUCH = 'touch';\n\t    var INPUT_TYPE_PEN = 'pen';\n\t    var INPUT_TYPE_MOUSE = 'mouse';\n\t    var INPUT_TYPE_KINECT = 'kinect';\n\t\n\t    var COMPUTE_INTERVAL = 25;\n\t\n\t    var INPUT_START = 1;\n\t    var INPUT_MOVE = 2;\n\t    var INPUT_END = 4;\n\t    var INPUT_CANCEL = 8;\n\t\n\t    var DIRECTION_NONE = 1;\n\t    var DIRECTION_LEFT = 2;\n\t    var DIRECTION_RIGHT = 4;\n\t    var DIRECTION_UP = 8;\n\t    var DIRECTION_DOWN = 16;\n\t\n\t    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n\t    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n\t    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\t\n\t    var PROPS_XY = ['x', 'y'];\n\t    var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\t\n\t    /**\n\t     * create new input type manager\n\t     * @param {Manager} manager\n\t     * @param {Function} callback\n\t     * @returns {Input}\n\t     * @constructor\n\t     */\n\t    function Input(manager, callback) {\n\t        var self = this;\n\t        this.manager = manager;\n\t        this.callback = callback;\n\t        this.element = manager.element;\n\t        this.target = manager.options.inputTarget;\n\t\n\t        // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n\t        // so when disabled the input events are completely bypassed.\n\t        this.domHandler = function(ev) {\n\t            if (boolOrFn(manager.options.enable, [manager])) {\n\t                self.handler(ev);\n\t            }\n\t        };\n\t\n\t        this.init();\n\t\n\t    }\n\t\n\t    Input.prototype = {\n\t        /**\n\t         * should handle the inputEvent data and trigger the callback\n\t         * @virtual\n\t         */\n\t        handler: function() {},\n\t\n\t        /**\n\t         * bind the events\n\t         */\n\t        init: function() {\n\t            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n\t            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n\t            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n\t        },\n\t\n\t        /**\n\t         * unbind the events\n\t         */\n\t        destroy: function() {\n\t            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n\t            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n\t            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * create new input type manager\n\t     * called by the Manager constructor\n\t     * @param {Hammer} manager\n\t     * @returns {Input}\n\t     */\n\t    function createInputInstance(manager) {\n\t        var Type;\n\t        var inputClass = manager.options.inputClass;\n\t\n\t        if (inputClass) {\n\t            Type = inputClass;\n\t        } else if (SUPPORT_POINTER_EVENTS) {\n\t            Type = PointerEventInput;\n\t        } else if (SUPPORT_ONLY_TOUCH) {\n\t            Type = TouchInput;\n\t        } else if (!SUPPORT_TOUCH) {\n\t            Type = MouseInput;\n\t        } else {\n\t            Type = TouchMouseInput;\n\t        }\n\t        return new(Type)(manager, inputHandler);\n\t    }\n\t\n\t    /**\n\t     * handle input events\n\t     * @param {Manager} manager\n\t     * @param {String} eventType\n\t     * @param {Object} input\n\t     */\n\t    function inputHandler(manager, eventType, input) {\n\t        var pointersLen = input.pointers.length;\n\t        var changedPointersLen = input.changedPointers.length;\n\t        var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n\t        var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\t\n\t        input.isFirst = !! isFirst;\n\t        input.isFinal = !! isFinal;\n\t\n\t        if (isFirst) {\n\t            manager.session = {};\n\t        }\n\t\n\t        // source event is the normalized value of the domEvents\n\t        // like 'touchstart, mouseup, pointerdown'\n\t        input.eventType = eventType;\n\t\n\t        // compute scale, rotation etc\n\t        computeInputData(manager, input);\n\t\n\t        // emit secret event\n\t        manager.emit('hammer.input', input);\n\t\n\t        manager.recognize(input);\n\t        manager.session.prevInput = input;\n\t    }\n\t\n\t    /**\n\t     * extend the data with some usable properties like scale, rotate, velocity etc\n\t     * @param {Object} manager\n\t     * @param {Object} input\n\t     */\n\t    function computeInputData(manager, input) {\n\t        var session = manager.session;\n\t        var pointers = input.pointers;\n\t        var pointersLength = pointers.length;\n\t\n\t        // store the first input to calculate the distance and direction\n\t        if (!session.firstInput) {\n\t            session.firstInput = simpleCloneInputData(input);\n\t        }\n\t\n\t        // to compute scale and rotation we need to store the multiple touches\n\t        if (pointersLength > 1 && !session.firstMultiple) {\n\t            session.firstMultiple = simpleCloneInputData(input);\n\t        } else if (pointersLength === 1) {\n\t            session.firstMultiple = false;\n\t        }\n\t\n\t        var firstInput = session.firstInput;\n\t        var firstMultiple = session.firstMultiple;\n\t        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\t\n\t        var center = input.center = getCenter(pointers);\n\t        input.timeStamp = now();\n\t        input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\t\n\t        input.angle = getAngle(offsetCenter, center);\n\t        input.distance = getDistance(offsetCenter, center);\n\t\n\t        computeDeltaXY(session, input);\n\t        input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\t\n\t        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n\t        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\t\n\t        computeIntervalInputData(session, input);\n\t\n\t        // find the correct target\n\t        var target = manager.element;\n\t        if (hasParent(input.srcEvent.target, target)) {\n\t            target = input.srcEvent.target;\n\t        }\n\t        input.target = target;\n\t    }\n\t\n\t    function computeDeltaXY(session, input) {\n\t        var center = input.center;\n\t        var offset = session.offsetDelta || {};\n\t        var prevDelta = session.prevDelta || {};\n\t        var prevInput = session.prevInput || {};\n\t\n\t        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n\t            prevDelta = session.prevDelta = {\n\t                x: prevInput.deltaX || 0,\n\t                y: prevInput.deltaY || 0\n\t            };\n\t\n\t            offset = session.offsetDelta = {\n\t                x: center.x,\n\t                y: center.y\n\t            };\n\t        }\n\t\n\t        input.deltaX = prevDelta.x + (center.x - offset.x);\n\t        input.deltaY = prevDelta.y + (center.y - offset.y);\n\t    }\n\t\n\t    /**\n\t     * velocity is calculated every x ms\n\t     * @param {Object} session\n\t     * @param {Object} input\n\t     */\n\t    function computeIntervalInputData(session, input) {\n\t        var last = session.lastInterval || input,\n\t            deltaTime = input.timeStamp - last.timeStamp,\n\t            velocity, velocityX, velocityY, direction;\n\t\n\t        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n\t            var deltaX = last.deltaX - input.deltaX;\n\t            var deltaY = last.deltaY - input.deltaY;\n\t\n\t            var v = getVelocity(deltaTime, deltaX, deltaY);\n\t            velocityX = v.x;\n\t            velocityY = v.y;\n\t            velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n\t            direction = getDirection(deltaX, deltaY);\n\t\n\t            session.lastInterval = input;\n\t        } else {\n\t            // use latest velocity info if it doesn't overtake a minimum period\n\t            velocity = last.velocity;\n\t            velocityX = last.velocityX;\n\t            velocityY = last.velocityY;\n\t            direction = last.direction;\n\t        }\n\t\n\t        input.velocity = velocity;\n\t        input.velocityX = velocityX;\n\t        input.velocityY = velocityY;\n\t        input.direction = direction;\n\t    }\n\t\n\t    /**\n\t     * create a simple clone from the input used for storage of firstInput and firstMultiple\n\t     * @param {Object} input\n\t     * @returns {Object} clonedInputData\n\t     */\n\t    function simpleCloneInputData(input) {\n\t        // make a simple copy of the pointers because we will get a reference if we don't\n\t        // we only need clientXY for the calculations\n\t        var pointers = [];\n\t        var i = 0;\n\t        while (i < input.pointers.length) {\n\t            pointers[i] = {\n\t                clientX: round(input.pointers[i].clientX),\n\t                clientY: round(input.pointers[i].clientY)\n\t            };\n\t            i++;\n\t        }\n\t\n\t        return {\n\t            timeStamp: now(),\n\t            pointers: pointers,\n\t            center: getCenter(pointers),\n\t            deltaX: input.deltaX,\n\t            deltaY: input.deltaY\n\t        };\n\t    }\n\t\n\t    /**\n\t     * get the center of all the pointers\n\t     * @param {Array} pointers\n\t     * @return {Object} center contains `x` and `y` properties\n\t     */\n\t    function getCenter(pointers) {\n\t        var pointersLength = pointers.length;\n\t\n\t        // no need to loop when only one touch\n\t        if (pointersLength === 1) {\n\t            return {\n\t                x: round(pointers[0].clientX),\n\t                y: round(pointers[0].clientY)\n\t            };\n\t        }\n\t\n\t        var x = 0,\n\t            y = 0,\n\t            i = 0;\n\t        while (i < pointersLength) {\n\t            x += pointers[i].clientX;\n\t            y += pointers[i].clientY;\n\t            i++;\n\t        }\n\t\n\t        return {\n\t            x: round(x / pointersLength),\n\t            y: round(y / pointersLength)\n\t        };\n\t    }\n\t\n\t    /**\n\t     * calculate the velocity between two points. unit is in px per ms.\n\t     * @param {Number} deltaTime\n\t     * @param {Number} x\n\t     * @param {Number} y\n\t     * @return {Object} velocity `x` and `y`\n\t     */\n\t    function getVelocity(deltaTime, x, y) {\n\t        return {\n\t            x: x / deltaTime || 0,\n\t            y: y / deltaTime || 0\n\t        };\n\t    }\n\t\n\t    /**\n\t     * get the direction between two points\n\t     * @param {Number} x\n\t     * @param {Number} y\n\t     * @return {Number} direction\n\t     */\n\t    function getDirection(x, y) {\n\t        if (x === y) {\n\t            return DIRECTION_NONE;\n\t        }\n\t\n\t        if (abs(x) >= abs(y)) {\n\t            return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n\t        }\n\t        return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\n\t    }\n\t\n\t    /**\n\t     * calculate the absolute distance between two points\n\t     * @param {Object} p1 {x, y}\n\t     * @param {Object} p2 {x, y}\n\t     * @param {Array} [props] containing x and y keys\n\t     * @return {Number} distance\n\t     */\n\t    function getDistance(p1, p2, props) {\n\t        if (!props) {\n\t            props = PROPS_XY;\n\t        }\n\t        var x = p2[props[0]] - p1[props[0]],\n\t            y = p2[props[1]] - p1[props[1]];\n\t\n\t        return Math.sqrt((x * x) + (y * y));\n\t    }\n\t\n\t    /**\n\t     * calculate the angle between two coordinates\n\t     * @param {Object} p1\n\t     * @param {Object} p2\n\t     * @param {Array} [props] containing x and y keys\n\t     * @return {Number} angle\n\t     */\n\t    function getAngle(p1, p2, props) {\n\t        if (!props) {\n\t            props = PROPS_XY;\n\t        }\n\t        var x = p2[props[0]] - p1[props[0]],\n\t            y = p2[props[1]] - p1[props[1]];\n\t        return Math.atan2(y, x) * 180 / Math.PI;\n\t    }\n\t\n\t    /**\n\t     * calculate the rotation degrees between two pointersets\n\t     * @param {Array} start array of pointers\n\t     * @param {Array} end array of pointers\n\t     * @return {Number} rotation\n\t     */\n\t    function getRotation(start, end) {\n\t        return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\n\t    }\n\t\n\t    /**\n\t     * calculate the scale factor between two pointersets\n\t     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n\t     * @param {Array} start array of pointers\n\t     * @param {Array} end array of pointers\n\t     * @return {Number} scale\n\t     */\n\t    function getScale(start, end) {\n\t        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n\t    }\n\t\n\t    var MOUSE_INPUT_MAP = {\n\t        mousedown: INPUT_START,\n\t        mousemove: INPUT_MOVE,\n\t        mouseup: INPUT_END\n\t    };\n\t\n\t    var MOUSE_ELEMENT_EVENTS = 'mousedown';\n\t    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\t\n\t    /**\n\t     * Mouse events input\n\t     * @constructor\n\t     * @extends Input\n\t     */\n\t    function MouseInput() {\n\t        this.evEl = MOUSE_ELEMENT_EVENTS;\n\t        this.evWin = MOUSE_WINDOW_EVENTS;\n\t\n\t        this.allow = true; // used by Input.TouchMouse to disable mouse events\n\t        this.pressed = false; // mousedown state\n\t\n\t        Input.apply(this, arguments);\n\t    }\n\t\n\t    inherit(MouseInput, Input, {\n\t        /**\n\t         * handle mouse events\n\t         * @param {Object} ev\n\t         */\n\t        handler: function MEhandler(ev) {\n\t            var eventType = MOUSE_INPUT_MAP[ev.type];\n\t\n\t            // on start we want to have the left mouse button down\n\t            if (eventType & INPUT_START && ev.button === 0) {\n\t                this.pressed = true;\n\t            }\n\t\n\t            if (eventType & INPUT_MOVE && ev.which !== 1) {\n\t                eventType = INPUT_END;\n\t            }\n\t\n\t            // mouse must be down, and mouse events are allowed (see the TouchMouse input)\n\t            if (!this.pressed || !this.allow) {\n\t                return;\n\t            }\n\t\n\t            if (eventType & INPUT_END) {\n\t                this.pressed = false;\n\t            }\n\t\n\t            this.callback(this.manager, eventType, {\n\t                pointers: [ev],\n\t                changedPointers: [ev],\n\t                pointerType: INPUT_TYPE_MOUSE,\n\t                srcEvent: ev\n\t            });\n\t        }\n\t    });\n\t\n\t    var POINTER_INPUT_MAP = {\n\t        pointerdown: INPUT_START,\n\t        pointermove: INPUT_MOVE,\n\t        pointerup: INPUT_END,\n\t        pointercancel: INPUT_CANCEL,\n\t        pointerout: INPUT_CANCEL\n\t    };\n\t\n\t    // in IE10 the pointer types is defined as an enum\n\t    var IE10_POINTER_TYPE_ENUM = {\n\t        2: INPUT_TYPE_TOUCH,\n\t        3: INPUT_TYPE_PEN,\n\t        4: INPUT_TYPE_MOUSE,\n\t        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\t    };\n\t\n\t    var POINTER_ELEMENT_EVENTS = 'pointerdown';\n\t    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\t\n\t    // IE10 has prefixed support, and case-sensitive\n\t    if (window.MSPointerEvent) {\n\t        POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n\t        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n\t    }\n\t\n\t    /**\n\t     * Pointer events input\n\t     * @constructor\n\t     * @extends Input\n\t     */\n\t    function PointerEventInput() {\n\t        this.evEl = POINTER_ELEMENT_EVENTS;\n\t        this.evWin = POINTER_WINDOW_EVENTS;\n\t\n\t        Input.apply(this, arguments);\n\t\n\t        this.store = (this.manager.session.pointerEvents = []);\n\t    }\n\t\n\t    inherit(PointerEventInput, Input, {\n\t        /**\n\t         * handle mouse events\n\t         * @param {Object} ev\n\t         */\n\t        handler: function PEhandler(ev) {\n\t            var store = this.store;\n\t            var removePointer = false;\n\t\n\t            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n\t            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n\t            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\t\n\t            var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\t\n\t            // get index of the event in the store\n\t            var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\t\n\t            // start and mouse must be down\n\t            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n\t                if (storeIndex < 0) {\n\t                    store.push(ev);\n\t                    storeIndex = store.length - 1;\n\t                }\n\t            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n\t                removePointer = true;\n\t            }\n\t\n\t            // it not found, so the pointer hasn't been down (so it's probably a hover)\n\t            if (storeIndex < 0) {\n\t                return;\n\t            }\n\t\n\t            // update the event in the store\n\t            store[storeIndex] = ev;\n\t\n\t            this.callback(this.manager, eventType, {\n\t                pointers: store,\n\t                changedPointers: [ev],\n\t                pointerType: pointerType,\n\t                srcEvent: ev\n\t            });\n\t\n\t            if (removePointer) {\n\t                // remove from the store\n\t                store.splice(storeIndex, 1);\n\t            }\n\t        }\n\t    });\n\t\n\t    var SINGLE_TOUCH_INPUT_MAP = {\n\t        touchstart: INPUT_START,\n\t        touchmove: INPUT_MOVE,\n\t        touchend: INPUT_END,\n\t        touchcancel: INPUT_CANCEL\n\t    };\n\t\n\t    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n\t    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\t\n\t    /**\n\t     * Touch events input\n\t     * @constructor\n\t     * @extends Input\n\t     */\n\t    function SingleTouchInput() {\n\t        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n\t        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n\t        this.started = false;\n\t\n\t        Input.apply(this, arguments);\n\t    }\n\t\n\t    inherit(SingleTouchInput, Input, {\n\t        handler: function TEhandler(ev) {\n\t            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\t\n\t            // should we handle the touch events?\n\t            if (type === INPUT_START) {\n\t                this.started = true;\n\t            }\n\t\n\t            if (!this.started) {\n\t                return;\n\t            }\n\t\n\t            var touches = normalizeSingleTouches.call(this, ev, type);\n\t\n\t            // when done, reset the started state\n\t            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n\t                this.started = false;\n\t            }\n\t\n\t            this.callback(this.manager, type, {\n\t                pointers: touches[0],\n\t                changedPointers: touches[1],\n\t                pointerType: INPUT_TYPE_TOUCH,\n\t                srcEvent: ev\n\t            });\n\t        }\n\t    });\n\t\n\t    /**\n\t     * @this {TouchInput}\n\t     * @param {Object} ev\n\t     * @param {Number} type flag\n\t     * @returns {undefined|Array} [all, changed]\n\t     */\n\t    function normalizeSingleTouches(ev, type) {\n\t        var all = toArray(ev.touches);\n\t        var changed = toArray(ev.changedTouches);\n\t\n\t        if (type & (INPUT_END | INPUT_CANCEL)) {\n\t            all = uniqueArray(all.concat(changed), 'identifier', true);\n\t        }\n\t\n\t        return [all, changed];\n\t    }\n\t\n\t    var TOUCH_INPUT_MAP = {\n\t        touchstart: INPUT_START,\n\t        touchmove: INPUT_MOVE,\n\t        touchend: INPUT_END,\n\t        touchcancel: INPUT_CANCEL\n\t    };\n\t\n\t    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\t\n\t    /**\n\t     * Multi-user touch events input\n\t     * @constructor\n\t     * @extends Input\n\t     */\n\t    function TouchInput() {\n\t        this.evTarget = TOUCH_TARGET_EVENTS;\n\t        this.targetIds = {};\n\t\n\t        Input.apply(this, arguments);\n\t    }\n\t\n\t    inherit(TouchInput, Input, {\n\t        handler: function MTEhandler(ev) {\n\t            var type = TOUCH_INPUT_MAP[ev.type];\n\t            var touches = getTouches.call(this, ev, type);\n\t            if (!touches) {\n\t                return;\n\t            }\n\t\n\t            this.callback(this.manager, type, {\n\t                pointers: touches[0],\n\t                changedPointers: touches[1],\n\t                pointerType: INPUT_TYPE_TOUCH,\n\t                srcEvent: ev\n\t            });\n\t        }\n\t    });\n\t\n\t    /**\n\t     * @this {TouchInput}\n\t     * @param {Object} ev\n\t     * @param {Number} type flag\n\t     * @returns {undefined|Array} [all, changed]\n\t     */\n\t    function getTouches(ev, type) {\n\t        var allTouches = toArray(ev.touches);\n\t        var targetIds = this.targetIds;\n\t\n\t        // when there is only one touch, the process can be simplified\n\t        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n\t            targetIds[allTouches[0].identifier] = true;\n\t            return [allTouches, allTouches];\n\t        }\n\t\n\t        var i,\n\t        targetTouches,\n\t        changedTouches = toArray(ev.changedTouches),\n\t            changedTargetTouches = [],\n\t            target = this.target;\n\t\n\t        // get target touches from touches\n\t        targetTouches = allTouches.filter(function(touch) {\n\t            return hasParent(touch.target, target);\n\t        });\n\t\n\t        // collect touches\n\t        if (type === INPUT_START) {\n\t            i = 0;\n\t            while (i < targetTouches.length) {\n\t                targetIds[targetTouches[i].identifier] = true;\n\t                i++;\n\t            }\n\t        }\n\t\n\t        // filter changed touches to only contain touches that exist in the collected target ids\n\t        i = 0;\n\t        while (i < changedTouches.length) {\n\t            if (targetIds[changedTouches[i].identifier]) {\n\t                changedTargetTouches.push(changedTouches[i]);\n\t            }\n\t\n\t            // cleanup removed touches\n\t            if (type & (INPUT_END | INPUT_CANCEL)) {\n\t                delete targetIds[changedTouches[i].identifier];\n\t            }\n\t            i++;\n\t        }\n\t\n\t        if (!changedTargetTouches.length) {\n\t            return;\n\t        }\n\t\n\t        return [\n\t        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n\t        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n\t        changedTargetTouches];\n\t    }\n\t\n\t    /**\n\t     * Combined touch and mouse input\n\t     *\n\t     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n\t     * This because touch devices also emit mouse events while doing a touch.\n\t     *\n\t     * @constructor\n\t     * @extends Input\n\t     */\n\t    function TouchMouseInput() {\n\t        Input.apply(this, arguments);\n\t\n\t        var handler = bindFn(this.handler, this);\n\t        this.touch = new TouchInput(this.manager, handler);\n\t        this.mouse = new MouseInput(this.manager, handler);\n\t    }\n\t\n\t    inherit(TouchMouseInput, Input, {\n\t        /**\n\t         * handle mouse and touch events\n\t         * @param {Hammer} manager\n\t         * @param {String} inputEvent\n\t         * @param {Object} inputData\n\t         */\n\t        handler: function TMEhandler(manager, inputEvent, inputData) {\n\t            var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n\t                isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\t\n\t            // when we're in a touch event, so  block all upcoming mouse events\n\t            // most mobile browser also emit mouseevents, right after touchstart\n\t            if (isTouch) {\n\t                this.mouse.allow = false;\n\t            } else if (isMouse && !this.mouse.allow) {\n\t                return;\n\t            }\n\t\n\t            // reset the allowMouse when we're done\n\t            if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\n\t                this.mouse.allow = true;\n\t            }\n\t\n\t            this.callback(manager, inputEvent, inputData);\n\t        },\n\t\n\t        /**\n\t         * remove the event listeners\n\t         */\n\t        destroy: function destroy() {\n\t            this.touch.destroy();\n\t            this.mouse.destroy();\n\t        }\n\t    });\n\t\n\t    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n\t    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\t\n\t    // magical touchAction value\n\t    var TOUCH_ACTION_COMPUTE = 'compute';\n\t    var TOUCH_ACTION_AUTO = 'auto';\n\t    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\t    var TOUCH_ACTION_NONE = 'none';\n\t    var TOUCH_ACTION_PAN_X = 'pan-x';\n\t    var TOUCH_ACTION_PAN_Y = 'pan-y';\n\t\n\t    /**\n\t     * Touch Action\n\t     * sets the touchAction property or uses the js alternative\n\t     * @param {Manager} manager\n\t     * @param {String} value\n\t     * @constructor\n\t     */\n\t    function TouchAction(manager, value) {\n\t        this.manager = manager;\n\t        this.set(value);\n\t    }\n\t\n\t    TouchAction.prototype = {\n\t        /**\n\t         * set the touchAction value on the element or enable the polyfill\n\t         * @param {String} value\n\t         */\n\t        set: function(value) {\n\t            // find out the touch-action by the event handlers\n\t            if (value == TOUCH_ACTION_COMPUTE) {\n\t                value = this.compute();\n\t            }\n\t\n\t            if (NATIVE_TOUCH_ACTION) {\n\t                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n\t            }\n\t            this.actions = value.toLowerCase().trim();\n\t        },\n\t\n\t        /**\n\t         * just re-set the touchAction value\n\t         */\n\t        update: function() {\n\t            this.set(this.manager.options.touchAction);\n\t        },\n\t\n\t        /**\n\t         * compute the value for the touchAction property based on the recognizer's settings\n\t         * @returns {String} value\n\t         */\n\t        compute: function() {\n\t            var actions = [];\n\t            each(this.manager.recognizers, function(recognizer) {\n\t                if (boolOrFn(recognizer.options.enable, [recognizer])) {\n\t                    actions = actions.concat(recognizer.getTouchAction());\n\t                }\n\t            });\n\t            return cleanTouchActions(actions.join(' '));\n\t        },\n\t\n\t        /**\n\t         * this method is called on each input cycle and provides the preventing of the browser behavior\n\t         * @param {Object} input\n\t         */\n\t        preventDefaults: function(input) {\n\t            // not needed with native support for the touchAction property\n\t            if (NATIVE_TOUCH_ACTION) {\n\t                return;\n\t            }\n\t\n\t            var srcEvent = input.srcEvent;\n\t            var direction = input.offsetDirection;\n\t\n\t            // if the touch action did prevented once this session\n\t            if (this.manager.session.prevented) {\n\t                srcEvent.preventDefault();\n\t                return;\n\t            }\n\t\n\t            var actions = this.actions;\n\t            var hasNone = inStr(actions, TOUCH_ACTION_NONE);\n\t            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\t            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n\t\n\t            if (hasNone || (hasPanY && direction & DIRECTION_HORIZONTAL) || (hasPanX && direction & DIRECTION_VERTICAL)) {\n\t                return this.preventSrc(srcEvent);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n\t         * @param {Object} srcEvent\n\t         */\n\t        preventSrc: function(srcEvent) {\n\t            this.manager.session.prevented = true;\n\t            srcEvent.preventDefault();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n\t     * @param {String} actions\n\t     * @returns {*}\n\t     */\n\t    function cleanTouchActions(actions) {\n\t        // none\n\t        if (inStr(actions, TOUCH_ACTION_NONE)) {\n\t            return TOUCH_ACTION_NONE;\n\t        }\n\t\n\t        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n\t        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\t\n\t        // pan-x and pan-y can be combined\n\t        if (hasPanX && hasPanY) {\n\t            return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;\n\t        }\n\t\n\t        // pan-x OR pan-y\n\t        if (hasPanX || hasPanY) {\n\t            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n\t        }\n\t\n\t        // manipulation\n\t        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n\t            return TOUCH_ACTION_MANIPULATION;\n\t        }\n\t\n\t        return TOUCH_ACTION_AUTO;\n\t    }\n\t\n\t    /**\n\t     * Recognizer flow explained; *\n\t     * All recognizers have the initial state of POSSIBLE when a input session starts.\n\t     * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n\t     * Example session for mouse-input: mousedown -> mousemove -> mouseup\n\t     *\n\t     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n\t     * which determines with state it should be.\n\t     *\n\t     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n\t     * POSSIBLE to give it another change on the next cycle.\n\t     *\n\t     *               Possible\n\t     *                  |\n\t     *            +-----+---------------+\n\t     *            |                     |\n\t     *      +-----+-----+               |\n\t     *      |           |               |\n\t     *   Failed      Cancelled          |\n\t     *                          +-------+------+\n\t     *                          |              |\n\t     *                      Recognized       Began\n\t     *                                         |\n\t     *                                      Changed\n\t     *                                         |\n\t     *                                  Ended/Recognized\n\t     */\n\t    var STATE_POSSIBLE = 1;\n\t    var STATE_BEGAN = 2;\n\t    var STATE_CHANGED = 4;\n\t    var STATE_ENDED = 8;\n\t    var STATE_RECOGNIZED = STATE_ENDED;\n\t    var STATE_CANCELLED = 16;\n\t    var STATE_FAILED = 32;\n\t\n\t    /**\n\t     * Recognizer\n\t     * Every recognizer needs to extend from this class.\n\t     * @constructor\n\t     * @param {Object} options\n\t     */\n\t    function Recognizer(options) {\n\t        this.id = uniqueId();\n\t\n\t        this.manager = null;\n\t        this.options = merge(options || {}, this.defaults);\n\t\n\t        // default is enable true\n\t        this.options.enable = ifUndefined(this.options.enable, true);\n\t\n\t        this.state = STATE_POSSIBLE;\n\t\n\t        this.simultaneous = {};\n\t        this.requireFail = [];\n\t    }\n\t\n\t    Recognizer.prototype = {\n\t        /**\n\t         * @virtual\n\t         * @type {Object}\n\t         */\n\t        defaults: {},\n\t\n\t        /**\n\t         * set options\n\t         * @param {Object} options\n\t         * @return {Recognizer}\n\t         */\n\t        set: function(options) {\n\t            extend(this.options, options);\n\t\n\t            // also update the touchAction, in case something changed about the directions/enabled state\n\t            this.manager && this.manager.touchAction.update();\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * recognize simultaneous with an other recognizer.\n\t         * @param {Recognizer} otherRecognizer\n\t         * @returns {Recognizer} this\n\t         */\n\t        recognizeWith: function(otherRecognizer) {\n\t            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n\t                return this;\n\t            }\n\t\n\t            var simultaneous = this.simultaneous;\n\t            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t            if (!simultaneous[otherRecognizer.id]) {\n\t                simultaneous[otherRecognizer.id] = otherRecognizer;\n\t                otherRecognizer.recognizeWith(this);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n\t         * @param {Recognizer} otherRecognizer\n\t         * @returns {Recognizer} this\n\t         */\n\t        dropRecognizeWith: function(otherRecognizer) {\n\t            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n\t                return this;\n\t            }\n\t\n\t            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t            delete this.simultaneous[otherRecognizer.id];\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * recognizer can only run when an other is failing\n\t         * @param {Recognizer} otherRecognizer\n\t         * @returns {Recognizer} this\n\t         */\n\t        requireFailure: function(otherRecognizer) {\n\t            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n\t                return this;\n\t            }\n\t\n\t            var requireFail = this.requireFail;\n\t            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t            if (inArray(requireFail, otherRecognizer) === -1) {\n\t                requireFail.push(otherRecognizer);\n\t                otherRecognizer.requireFailure(this);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * drop the requireFailure link. it does not remove the link on the other recognizer.\n\t         * @param {Recognizer} otherRecognizer\n\t         * @returns {Recognizer} this\n\t         */\n\t        dropRequireFailure: function(otherRecognizer) {\n\t            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n\t                return this;\n\t            }\n\t\n\t            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t            var index = inArray(this.requireFail, otherRecognizer);\n\t            if (index > -1) {\n\t                this.requireFail.splice(index, 1);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * has require failures boolean\n\t         * @returns {boolean}\n\t         */\n\t        hasRequireFailures: function() {\n\t            return this.requireFail.length > 0;\n\t        },\n\t\n\t        /**\n\t         * if the recognizer can recognize simultaneous with an other recognizer\n\t         * @param {Recognizer} otherRecognizer\n\t         * @returns {Boolean}\n\t         */\n\t        canRecognizeWith: function(otherRecognizer) {\n\t            return !!this.simultaneous[otherRecognizer.id];\n\t        },\n\t\n\t        /**\n\t         * You should use `tryEmit` instead of `emit` directly to check\n\t         * that all the needed recognizers has failed before emitting.\n\t         * @param {Object} input\n\t         */\n\t        emit: function(input) {\n\t            var self = this;\n\t            var state = this.state;\n\t\n\t            function emit(withState) {\n\t                self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);\n\t            }\n\t\n\t            // 'panstart' and 'panmove'\n\t            if (state < STATE_ENDED) {\n\t                emit(true);\n\t            }\n\t\n\t            emit(); // simple 'eventName' events\n\t\n\t            // panend and pancancel\n\t            if (state >= STATE_ENDED) {\n\t                emit(true);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Check that all the require failure recognizers has failed,\n\t         * if true, it emits a gesture event,\n\t         * otherwise, setup the state to FAILED.\n\t         * @param {Object} input\n\t         */\n\t        tryEmit: function(input) {\n\t            if (this.canEmit()) {\n\t                return this.emit(input);\n\t            }\n\t            // it's failing anyway\n\t            this.state = STATE_FAILED;\n\t        },\n\t\n\t        /**\n\t         * can we emit?\n\t         * @returns {boolean}\n\t         */\n\t        canEmit: function() {\n\t            var i = 0;\n\t            while (i < this.requireFail.length) {\n\t                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n\t                    return false;\n\t                }\n\t                i++;\n\t            }\n\t            return true;\n\t        },\n\t\n\t        /**\n\t         * update the recognizer\n\t         * @param {Object} inputData\n\t         */\n\t        recognize: function(inputData) {\n\t            // make a new copy of the inputData\n\t            // so we can change the inputData without messing up the other recognizers\n\t            var inputDataClone = extend({}, inputData);\n\t\n\t            // is is enabled and allow recognizing?\n\t            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n\t                this.reset();\n\t                this.state = STATE_FAILED;\n\t                return;\n\t            }\n\t\n\t            // reset when we've reached the end\n\t            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n\t                this.state = STATE_POSSIBLE;\n\t            }\n\t\n\t            this.state = this.process(inputDataClone);\n\t\n\t            // the recognizer has recognized a gesture\n\t            // so trigger an event\n\t            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n\t                this.tryEmit(inputDataClone);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * return the state of the recognizer\n\t         * the actual recognizing happens in this method\n\t         * @virtual\n\t         * @param {Object} inputData\n\t         * @returns {Const} STATE\n\t         */\n\t        process: function(inputData) {}, // jshint ignore:line\n\t\n\t        /**\n\t         * return the preferred touch-action\n\t         * @virtual\n\t         * @returns {Array}\n\t         */\n\t        getTouchAction: function() {},\n\t\n\t        /**\n\t         * called when the gesture isn't allowed to recognize\n\t         * like when another is being recognized or it is disabled\n\t         * @virtual\n\t         */\n\t        reset: function() {}\n\t    };\n\t\n\t    /**\n\t     * get a usable string, used as event postfix\n\t     * @param {Const} state\n\t     * @returns {String} state\n\t     */\n\t    function stateStr(state) {\n\t        if (state & STATE_CANCELLED) {\n\t            return 'cancel';\n\t        } else if (state & STATE_ENDED) {\n\t            return 'end';\n\t        } else if (state & STATE_CHANGED) {\n\t            return 'move';\n\t        } else if (state & STATE_BEGAN) {\n\t            return 'start';\n\t        }\n\t        return '';\n\t    }\n\t\n\t    /**\n\t     * direction cons to string\n\t     * @param {Const} direction\n\t     * @returns {String}\n\t     */\n\t    function directionStr(direction) {\n\t        if (direction == DIRECTION_DOWN) {\n\t            return 'down';\n\t        } else if (direction == DIRECTION_UP) {\n\t            return 'up';\n\t        } else if (direction == DIRECTION_LEFT) {\n\t            return 'left';\n\t        } else if (direction == DIRECTION_RIGHT) {\n\t            return 'right';\n\t        }\n\t        return '';\n\t    }\n\t\n\t    /**\n\t     * get a recognizer by name if it is bound to a manager\n\t     * @param {Recognizer|String} otherRecognizer\n\t     * @param {Recognizer} recognizer\n\t     * @returns {Recognizer}\n\t     */\n\t    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n\t        var manager = recognizer.manager;\n\t        if (manager) {\n\t            return manager.get(otherRecognizer);\n\t        }\n\t        return otherRecognizer;\n\t    }\n\t\n\t    /**\n\t     * This recognizer is just used as a base for the simple attribute recognizers.\n\t     * @constructor\n\t     * @extends Recognizer\n\t     */\n\t    function AttrRecognizer() {\n\t        Recognizer.apply(this, arguments);\n\t    }\n\t\n\t    inherit(AttrRecognizer, Recognizer, {\n\t        /**\n\t         * @namespace\n\t         * @memberof AttrRecognizer\n\t         */\n\t        defaults: {\n\t            /**\n\t             * @type {Number}\n\t             * @default 1\n\t             */\n\t            pointers: 1\n\t        },\n\t\n\t        /**\n\t         * Used to check if it the recognizer receives valid input, like input.distance > 10.\n\t         * @memberof AttrRecognizer\n\t         * @param {Object} input\n\t         * @returns {Boolean} recognized\n\t         */\n\t        attrTest: function(input) {\n\t            var optionPointers = this.options.pointers;\n\t            return optionPointers === 0 || input.pointers.length === optionPointers;\n\t        },\n\t\n\t        /**\n\t         * Process the input and return the state for the recognizer\n\t         * @memberof AttrRecognizer\n\t         * @param {Object} input\n\t         * @returns {*} State\n\t         */\n\t        process: function(input) {\n\t            var state = this.state;\n\t            var eventType = input.eventType;\n\t\n\t            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n\t            var isValid = this.attrTest(input);\n\t\n\t            // on cancel input and we've recognized before, return STATE_CANCELLED\n\t            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n\t                return state | STATE_CANCELLED;\n\t            } else if (isRecognized || isValid) {\n\t                if (eventType & INPUT_END) {\n\t                    return state | STATE_ENDED;\n\t                } else if (!(state & STATE_BEGAN)) {\n\t                    return STATE_BEGAN;\n\t                }\n\t                return state | STATE_CHANGED;\n\t            }\n\t            return STATE_FAILED;\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Pan\n\t     * Recognized when the pointer is down and moved in the allowed direction.\n\t     * @constructor\n\t     * @extends AttrRecognizer\n\t     */\n\t    function PanRecognizer() {\n\t        AttrRecognizer.apply(this, arguments);\n\t\n\t        this.pX = null;\n\t        this.pY = null;\n\t    }\n\t\n\t    inherit(PanRecognizer, AttrRecognizer, {\n\t        /**\n\t         * @namespace\n\t         * @memberof PanRecognizer\n\t         */\n\t        defaults: {\n\t            event: 'pan',\n\t            threshold: 10,\n\t            pointers: 1,\n\t            direction: DIRECTION_ALL\n\t        },\n\t\n\t        getTouchAction: function() {\n\t            var direction = this.options.direction;\n\t            var actions = [];\n\t            if (direction & DIRECTION_HORIZONTAL) {\n\t                actions.push(TOUCH_ACTION_PAN_Y);\n\t            }\n\t            if (direction & DIRECTION_VERTICAL) {\n\t                actions.push(TOUCH_ACTION_PAN_X);\n\t            }\n\t            return actions;\n\t        },\n\t\n\t        directionTest: function(input) {\n\t            var options = this.options;\n\t            var hasMoved = true;\n\t            var distance = input.distance;\n\t            var direction = input.direction;\n\t            var x = input.deltaX;\n\t            var y = input.deltaY;\n\t\n\t            // lock to axis?\n\t            if (!(direction & options.direction)) {\n\t                if (options.direction & DIRECTION_HORIZONTAL) {\n\t                    direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n\t                    hasMoved = x != this.pX;\n\t                    distance = Math.abs(input.deltaX);\n\t                } else {\n\t                    direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n\t                    hasMoved = y != this.pY;\n\t                    distance = Math.abs(input.deltaY);\n\t                }\n\t            }\n\t            input.direction = direction;\n\t            return hasMoved && distance > options.threshold && direction & options.direction;\n\t        },\n\t\n\t        attrTest: function(input) {\n\t            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n\t        },\n\t\n\t        emit: function(input) {\n\t            this.pX = input.deltaX;\n\t            this.pY = input.deltaY;\n\t\n\t            var direction = directionStr(input.direction);\n\t            if (direction) {\n\t                this.manager.emit(this.options.event + direction, input);\n\t            }\n\t\n\t            this._super.emit.call(this, input);\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Pinch\n\t     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n\t     * @constructor\n\t     * @extends AttrRecognizer\n\t     */\n\t    function PinchRecognizer() {\n\t        AttrRecognizer.apply(this, arguments);\n\t    }\n\t\n\t    inherit(PinchRecognizer, AttrRecognizer, {\n\t        /**\n\t         * @namespace\n\t         * @memberof PinchRecognizer\n\t         */\n\t        defaults: {\n\t            event: 'pinch',\n\t            threshold: 0,\n\t            pointers: 2\n\t        },\n\t\n\t        getTouchAction: function() {\n\t            return [TOUCH_ACTION_NONE];\n\t        },\n\t\n\t        attrTest: function(input) {\n\t            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n\t        },\n\t\n\t        emit: function(input) {\n\t            this._super.emit.call(this, input);\n\t            if (input.scale !== 1) {\n\t                var inOut = input.scale < 1 ? 'in' : 'out';\n\t                this.manager.emit(this.options.event + inOut, input);\n\t            }\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Press\n\t     * Recognized when the pointer is down for x ms without any movement.\n\t     * @constructor\n\t     * @extends Recognizer\n\t     */\n\t    function PressRecognizer() {\n\t        Recognizer.apply(this, arguments);\n\t\n\t        this._timer = null;\n\t        this._input = null;\n\t    }\n\t\n\t    inherit(PressRecognizer, Recognizer, {\n\t        /**\n\t         * @namespace\n\t         * @memberof PressRecognizer\n\t         */\n\t        defaults: {\n\t            event: 'press',\n\t            pointers: 1,\n\t            time: 500, // minimal time of the pointer to be pressed\n\t            threshold: 5 // a minimal movement is ok, but keep it low\n\t        },\n\t\n\t        getTouchAction: function() {\n\t            return [TOUCH_ACTION_AUTO];\n\t        },\n\t\n\t        process: function(input) {\n\t            var options = this.options;\n\t            var validPointers = input.pointers.length === options.pointers;\n\t            var validMovement = input.distance < options.threshold;\n\t            var validTime = input.deltaTime > options.time;\n\t\n\t            this._input = input;\n\t\n\t            // we only allow little movement\n\t            // and we've reached an end event, so a tap is possible\n\t            if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n\t                this.reset();\n\t            } else if (input.eventType & INPUT_START) {\n\t                this.reset();\n\t                this._timer = setTimeoutContext(function() {\n\t                    this.state = STATE_RECOGNIZED;\n\t                    this.tryEmit();\n\t                }, options.time, this);\n\t            } else if (input.eventType & INPUT_END) {\n\t                return STATE_RECOGNIZED;\n\t            }\n\t            return STATE_FAILED;\n\t        },\n\t\n\t        reset: function() {\n\t            clearTimeout(this._timer);\n\t        },\n\t\n\t        emit: function(input) {\n\t            if (this.state !== STATE_RECOGNIZED) {\n\t                return;\n\t            }\n\t\n\t            if (input && (input.eventType & INPUT_END)) {\n\t                this.manager.emit(this.options.event + 'up', input);\n\t            } else {\n\t                this._input.timeStamp = now();\n\t                this.manager.emit(this.options.event, this._input);\n\t            }\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Rotate\n\t     * Recognized when two or more pointer are moving in a circular motion.\n\t     * @constructor\n\t     * @extends AttrRecognizer\n\t     */\n\t    function RotateRecognizer() {\n\t        AttrRecognizer.apply(this, arguments);\n\t    }\n\t\n\t    inherit(RotateRecognizer, AttrRecognizer, {\n\t        /**\n\t         * @namespace\n\t         * @memberof RotateRecognizer\n\t         */\n\t        defaults: {\n\t            event: 'rotate',\n\t            threshold: 0,\n\t            pointers: 2\n\t        },\n\t\n\t        getTouchAction: function() {\n\t            return [TOUCH_ACTION_NONE];\n\t        },\n\t\n\t        attrTest: function(input) {\n\t            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Swipe\n\t     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n\t     * @constructor\n\t     * @extends AttrRecognizer\n\t     */\n\t    function SwipeRecognizer() {\n\t        AttrRecognizer.apply(this, arguments);\n\t    }\n\t\n\t    inherit(SwipeRecognizer, AttrRecognizer, {\n\t        /**\n\t         * @namespace\n\t         * @memberof SwipeRecognizer\n\t         */\n\t        defaults: {\n\t            event: 'swipe',\n\t            threshold: 10,\n\t            velocity: 0.65,\n\t            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n\t            pointers: 1\n\t        },\n\t\n\t        getTouchAction: function() {\n\t            return PanRecognizer.prototype.getTouchAction.call(this);\n\t        },\n\t\n\t        attrTest: function(input) {\n\t            var direction = this.options.direction;\n\t            var velocity;\n\t\n\t            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n\t                velocity = input.velocity;\n\t            } else if (direction & DIRECTION_HORIZONTAL) {\n\t                velocity = input.velocityX;\n\t            } else if (direction & DIRECTION_VERTICAL) {\n\t                velocity = input.velocityY;\n\t            }\n\t\n\t            return this._super.attrTest.call(this, input) && direction & input.direction && input.distance > this.options.threshold && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n\t        },\n\t\n\t        emit: function(input) {\n\t            var direction = directionStr(input.direction);\n\t            if (direction) {\n\t                this.manager.emit(this.options.event + direction, input);\n\t            }\n\t\n\t            this.manager.emit(this.options.event, input);\n\t        }\n\t    });\n\t\n\t    /**\n\t     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n\t     * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n\t     * a single tap.\n\t     *\n\t     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n\t     * multi-taps being recognized.\n\t     * @constructor\n\t     * @extends Recognizer\n\t     */\n\t    function TapRecognizer() {\n\t        Recognizer.apply(this, arguments);\n\t\n\t        // previous time and center,\n\t        // used for tap counting\n\t        this.pTime = false;\n\t        this.pCenter = false;\n\t\n\t        this._timer = null;\n\t        this._input = null;\n\t        this.count = 0;\n\t    }\n\t\n\t    inherit(TapRecognizer, Recognizer, {\n\t        /**\n\t         * @namespace\n\t         * @memberof PinchRecognizer\n\t         */\n\t        defaults: {\n\t            event: 'tap',\n\t            pointers: 1,\n\t            taps: 1,\n\t            interval: 300, // max time between the multi-tap taps\n\t            time: 250, // max time of the pointer to be down (like finger on the screen)\n\t            threshold: 2, // a minimal movement is ok, but keep it low\n\t            posThreshold: 10 // a multi-tap can be a bit off the initial position\n\t        },\n\t\n\t        getTouchAction: function() {\n\t            return [TOUCH_ACTION_MANIPULATION];\n\t        },\n\t\n\t        process: function(input) {\n\t            var options = this.options;\n\t\n\t            var validPointers = input.pointers.length === options.pointers;\n\t            var validMovement = input.distance < options.threshold;\n\t            var validTouchTime = input.deltaTime < options.time;\n\t\n\t            this.reset();\n\t\n\t            if ((input.eventType & INPUT_START) && (this.count === 0)) {\n\t                return this.failTimeout();\n\t            }\n\t\n\t            // we only allow little movement\n\t            // and we've reached an end event, so a tap is possible\n\t            if (validMovement && validTouchTime && validPointers) {\n\t                if (input.eventType != INPUT_END) {\n\t                    return this.failTimeout();\n\t                }\n\t\n\t                var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n\t                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\t\n\t                this.pTime = input.timeStamp;\n\t                this.pCenter = input.center;\n\t\n\t                if (!validMultiTap || !validInterval) {\n\t                    this.count = 1;\n\t                } else {\n\t                    this.count += 1;\n\t                }\n\t\n\t                this._input = input;\n\t\n\t                // if tap count matches we have recognized it,\n\t                // else it has began recognizing...\n\t                var tapCount = this.count % options.taps;\n\t                if (tapCount === 0) {\n\t                    // no failing requirements, immediately trigger the tap event\n\t                    // or wait as long as the multitap interval to trigger\n\t                    if (!this.hasRequireFailures()) {\n\t                        return STATE_RECOGNIZED;\n\t                    } else {\n\t                        this._timer = setTimeoutContext(function() {\n\t                            this.state = STATE_RECOGNIZED;\n\t                            this.tryEmit();\n\t                        }, options.interval, this);\n\t                        return STATE_BEGAN;\n\t                    }\n\t                }\n\t            }\n\t            return STATE_FAILED;\n\t        },\n\t\n\t        failTimeout: function() {\n\t            this._timer = setTimeoutContext(function() {\n\t                this.state = STATE_FAILED;\n\t            }, this.options.interval, this);\n\t            return STATE_FAILED;\n\t        },\n\t\n\t        reset: function() {\n\t            clearTimeout(this._timer);\n\t        },\n\t\n\t        emit: function() {\n\t            if (this.state == STATE_RECOGNIZED) {\n\t                this._input.tapCount = this.count;\n\t                this.manager.emit(this.options.event, this._input);\n\t            }\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Simple way to create an manager with a default set of recognizers.\n\t     * @param {HTMLElement} element\n\t     * @param {Object} [options]\n\t     * @constructor\n\t     */\n\t    function Hammer(element, options) {\n\t        options = options || {};\n\t        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n\t        return new Manager(element, options);\n\t    }\n\t\n\t    /**\n\t     * @const {string}\n\t     */\n\t    Hammer.VERSION = '2.0.4';\n\t\n\t    /**\n\t     * default settings\n\t     * @namespace\n\t     */\n\t    Hammer.defaults = {\n\t        /**\n\t         * set if DOM events are being triggered.\n\t         * But this is slower and unused by simple implementations, so disabled by default.\n\t         * @type {Boolean}\n\t         * @default false\n\t         */\n\t        domEvents: false,\n\t\n\t        /**\n\t         * The value for the touchAction property/fallback.\n\t         * When set to `compute` it will magically set the correct value based on the added recognizers.\n\t         * @type {String}\n\t         * @default compute\n\t         */\n\t        touchAction: TOUCH_ACTION_COMPUTE,\n\t\n\t        /**\n\t         * @type {Boolean}\n\t         * @default true\n\t         */\n\t        enable: true,\n\t\n\t        /**\n\t         * EXPERIMENTAL FEATURE -- can be removed/changed\n\t         * Change the parent input target element.\n\t         * If Null, then it is being set the to main element.\n\t         * @type {Null|EventTarget}\n\t         * @default null\n\t         */\n\t        inputTarget: null,\n\t\n\t        /**\n\t         * force an input class\n\t         * @type {Null|Function}\n\t         * @default null\n\t         */\n\t        inputClass: null,\n\t\n\t        /**\n\t         * Default recognizer setup when calling `Hammer()`\n\t         * When creating a new Manager these will be skipped.\n\t         * @type {Array}\n\t         */\n\t        preset: [\n\t        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n\t        [RotateRecognizer, {\n\t            enable: false\n\t        }],\n\t            [PinchRecognizer, {\n\t                enable: false\n\t            }, ['rotate']],\n\t            [SwipeRecognizer, {\n\t                direction: DIRECTION_HORIZONTAL\n\t            }],\n\t            [PanRecognizer, {\n\t                direction: DIRECTION_HORIZONTAL\n\t            }, ['swipe']],\n\t            [TapRecognizer],\n\t            [TapRecognizer, {\n\t                event: 'doubletap',\n\t                taps: 2\n\t            }, ['tap']],\n\t            [PressRecognizer]\n\t        ],\n\t\n\t        /**\n\t         * Some CSS properties can be used to improve the working of Hammer.\n\t         * Add them to this method and they will be set when creating a new Manager.\n\t         * @namespace\n\t         */\n\t        cssProps: {\n\t            /**\n\t             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n\t             * @type {String}\n\t             * @default 'none'\n\t             */\n\t            userSelect: 'none',\n\t\n\t            /**\n\t             * Disable the Windows Phone grippers when pressing an element.\n\t             * @type {String}\n\t             * @default 'none'\n\t             */\n\t            touchSelect: 'none',\n\t\n\t            /**\n\t             * Disables the default callout shown when you touch and hold a touch target.\n\t             * On iOS, when you touch and hold a touch target such as a link, Safari displays\n\t             * a callout containing information about the link. This property allows you to disable that callout.\n\t             * @type {String}\n\t             * @default 'none'\n\t             */\n\t            touchCallout: 'none',\n\t\n\t            /**\n\t             * Specifies whether zooming is enabled. Used by IE10>\n\t             * @type {String}\n\t             * @default 'none'\n\t             */\n\t            contentZooming: 'none',\n\t\n\t            /**\n\t             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n\t             * @type {String}\n\t             * @default 'none'\n\t             */\n\t            userDrag: 'none',\n\t\n\t            /**\n\t             * Overrides the highlight color shown when the user taps a link or a JavaScript\n\t             * clickable element in iOS. This property obeys the alpha value, if specified.\n\t             * @type {String}\n\t             * @default 'rgba(0,0,0,0)'\n\t             */\n\t            tapHighlightColor: 'rgba(0,0,0,0)'\n\t        }\n\t    };\n\t\n\t    var STOP = 1;\n\t    var FORCED_STOP = 2;\n\t\n\t    /**\n\t     * Manager\n\t     * @param {HTMLElement} element\n\t     * @param {Object} [options]\n\t     * @constructor\n\t     */\n\t    function Manager(element, options) {\n\t        options = options || {};\n\t\n\t        this.options = merge(options, Hammer.defaults);\n\t        this.options.inputTarget = this.options.inputTarget || element;\n\t\n\t        this.handlers = {};\n\t        this.session = {};\n\t        this.recognizers = [];\n\t\n\t        this.element = element;\n\t        this.input = createInputInstance(this);\n\t        this.touchAction = new TouchAction(this, this.options.touchAction);\n\t\n\t        toggleCssProps(this, true);\n\t\n\t        each(options.recognizers, function(item) {\n\t            var recognizer = this.add(new(item[0])(item[1]));\n\t            item[2] && recognizer.recognizeWith(item[2]);\n\t            item[3] && recognizer.requireFailure(item[3]);\n\t        }, this);\n\t    }\n\t\n\t    Manager.prototype = {\n\t        /**\n\t         * set options\n\t         * @param {Object} options\n\t         * @returns {Manager}\n\t         */\n\t        set: function(options) {\n\t            extend(this.options, options);\n\t\n\t            // Options that need a little more setup\n\t            if (options.touchAction) {\n\t                this.touchAction.update();\n\t            }\n\t            if (options.inputTarget) {\n\t                // Clean up existing event listeners and reinitialize\n\t                this.input.destroy();\n\t                this.input.target = options.inputTarget;\n\t                this.input.init();\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * stop recognizing for this session.\n\t         * This session will be discarded, when a new [input]start event is fired.\n\t         * When forced, the recognizer cycle is stopped immediately.\n\t         * @param {Boolean} [force]\n\t         */\n\t        stop: function(force) {\n\t            this.session.stopped = force ? FORCED_STOP : STOP;\n\t        },\n\t\n\t        /**\n\t         * run the recognizers!\n\t         * called by the inputHandler function on every movement of the pointers (touches)\n\t         * it walks through all the recognizers and tries to detect the gesture that is being made\n\t         * @param {Object} inputData\n\t         */\n\t        recognize: function(inputData) {\n\t            var session = this.session;\n\t            if (session.stopped) {\n\t                return;\n\t            }\n\t\n\t            // run the touch-action polyfill\n\t            this.touchAction.preventDefaults(inputData);\n\t\n\t            var recognizer;\n\t            var recognizers = this.recognizers;\n\t\n\t            // this holds the recognizer that is being recognized.\n\t            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n\t            // if no recognizer is detecting a thing, it is set to `null`\n\t            var curRecognizer = session.curRecognizer;\n\t\n\t            // reset when the last recognizer is recognized\n\t            // or when we're in a new session\n\t            if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n\t                curRecognizer = session.curRecognizer = null;\n\t            }\n\t\n\t            var i = 0;\n\t            while (i < recognizers.length) {\n\t                recognizer = recognizers[i];\n\t\n\t                // find out if we are allowed try to recognize the input for this one.\n\t                // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n\t                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n\t                //      that is being recognized.\n\t                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n\t                //      this can be setup with the `recognizeWith()` method on the recognizer.\n\t                if (session.stopped !== FORCED_STOP && ( // 1\n\t                !curRecognizer || recognizer == curRecognizer || // 2\n\t                recognizer.canRecognizeWith(curRecognizer))) { // 3\n\t                    recognizer.recognize(inputData);\n\t                } else {\n\t                    recognizer.reset();\n\t                }\n\t\n\t                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n\t                // current active recognizer. but only if we don't already have an active recognizer\n\t                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n\t                    curRecognizer = session.curRecognizer = recognizer;\n\t                }\n\t                i++;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * get a recognizer by its event name.\n\t         * @param {Recognizer|String} recognizer\n\t         * @returns {Recognizer|Null}\n\t         */\n\t        get: function(recognizer) {\n\t            if (recognizer instanceof Recognizer) {\n\t                return recognizer;\n\t            }\n\t\n\t            var recognizers = this.recognizers;\n\t            for (var i = 0; i < recognizers.length; i++) {\n\t                if (recognizers[i].options.event == recognizer) {\n\t                    return recognizers[i];\n\t                }\n\t            }\n\t            return null;\n\t        },\n\t\n\t        /**\n\t         * add a recognizer to the manager\n\t         * existing recognizers with the same event name will be removed\n\t         * @param {Recognizer} recognizer\n\t         * @returns {Recognizer|Manager}\n\t         */\n\t        add: function(recognizer) {\n\t            if (invokeArrayArg(recognizer, 'add', this)) {\n\t                return this;\n\t            }\n\t\n\t            // remove existing\n\t            var existing = this.get(recognizer.options.event);\n\t            if (existing) {\n\t                this.remove(existing);\n\t            }\n\t\n\t            this.recognizers.push(recognizer);\n\t            recognizer.manager = this;\n\t\n\t            this.touchAction.update();\n\t            return recognizer;\n\t        },\n\t\n\t        /**\n\t         * remove a recognizer by name or instance\n\t         * @param {Recognizer|String} recognizer\n\t         * @returns {Manager}\n\t         */\n\t        remove: function(recognizer) {\n\t            if (invokeArrayArg(recognizer, 'remove', this)) {\n\t                return this;\n\t            }\n\t\n\t            var recognizers = this.recognizers;\n\t            recognizer = this.get(recognizer);\n\t            recognizers.splice(inArray(recognizers, recognizer), 1);\n\t\n\t            this.touchAction.update();\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * bind event\n\t         * @param {String} events\n\t         * @param {Function} handler\n\t         * @returns {EventEmitter} this\n\t         */\n\t        on: function(events, handler) {\n\t            var handlers = this.handlers;\n\t            each(splitStr(events), function(event) {\n\t                handlers[event] = handlers[event] || [];\n\t                handlers[event].push(handler);\n\t            });\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * unbind event, leave emit blank to remove all handlers\n\t         * @param {String} events\n\t         * @param {Function} [handler]\n\t         * @returns {EventEmitter} this\n\t         */\n\t        off: function(events, handler) {\n\t            var handlers = this.handlers;\n\t            each(splitStr(events), function(event) {\n\t                if (!handler) {\n\t                    delete handlers[event];\n\t                } else {\n\t                    handlers[event].splice(inArray(handlers[event], handler), 1);\n\t                }\n\t            });\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * emit event to the listeners\n\t         * @param {String} event\n\t         * @param {Object} data\n\t         */\n\t        emit: function(event, data) {\n\t            // we also want to trigger dom events\n\t            if (this.options.domEvents) {\n\t                triggerDomEvent(event, data);\n\t            }\n\t\n\t            // no handlers, so skip it all\n\t            var handlers = this.handlers[event] && this.handlers[event].slice();\n\t            if (!handlers || !handlers.length) {\n\t                return;\n\t            }\n\t\n\t            data.type = event;\n\t            data.preventDefault = function() {\n\t                data.srcEvent.preventDefault();\n\t            };\n\t\n\t            var i = 0;\n\t            while (i < handlers.length) {\n\t                handlers[i](data);\n\t                i++;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * destroy the manager and unbinds all events\n\t         * it doesn't unbind dom events, that is the user own responsibility\n\t         */\n\t        destroy: function() {\n\t            this.element && toggleCssProps(this, false);\n\t\n\t            this.handlers = {};\n\t            this.session = {};\n\t            this.input.destroy();\n\t            this.element = null;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * add/remove the css properties as defined in manager.options.cssProps\n\t     * @param {Manager} manager\n\t     * @param {Boolean} add\n\t     */\n\t    function toggleCssProps(manager, add) {\n\t        var element = manager.element;\n\t        each(manager.options.cssProps, function(value, name) {\n\t            element.style[prefixed(element.style, name)] = add ? value : '';\n\t        });\n\t    }\n\t\n\t    /**\n\t     * trigger dom event\n\t     * @param {String} event\n\t     * @param {Object} data\n\t     */\n\t    function triggerDomEvent(event, data) {\n\t        var gestureEvent = document.createEvent('Event');\n\t        gestureEvent.initEvent(event, true, true);\n\t        gestureEvent.gesture = data;\n\t        data.target.dispatchEvent(gestureEvent);\n\t    }\n\t\n\t    extend(Hammer, {\n\t        INPUT_START: INPUT_START,\n\t        INPUT_MOVE: INPUT_MOVE,\n\t        INPUT_END: INPUT_END,\n\t        INPUT_CANCEL: INPUT_CANCEL,\n\t\n\t        STATE_POSSIBLE: STATE_POSSIBLE,\n\t        STATE_BEGAN: STATE_BEGAN,\n\t        STATE_CHANGED: STATE_CHANGED,\n\t        STATE_ENDED: STATE_ENDED,\n\t        STATE_RECOGNIZED: STATE_RECOGNIZED,\n\t        STATE_CANCELLED: STATE_CANCELLED,\n\t        STATE_FAILED: STATE_FAILED,\n\t\n\t        DIRECTION_NONE: DIRECTION_NONE,\n\t        DIRECTION_LEFT: DIRECTION_LEFT,\n\t        DIRECTION_RIGHT: DIRECTION_RIGHT,\n\t        DIRECTION_UP: DIRECTION_UP,\n\t        DIRECTION_DOWN: DIRECTION_DOWN,\n\t        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n\t        DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n\t        DIRECTION_ALL: DIRECTION_ALL,\n\t\n\t        Manager: Manager,\n\t        Input: Input,\n\t        TouchAction: TouchAction,\n\t\n\t        TouchInput: TouchInput,\n\t        MouseInput: MouseInput,\n\t        PointerEventInput: PointerEventInput,\n\t        TouchMouseInput: TouchMouseInput,\n\t        SingleTouchInput: SingleTouchInput,\n\t\n\t        Recognizer: Recognizer,\n\t        AttrRecognizer: AttrRecognizer,\n\t        Tap: TapRecognizer,\n\t        Pan: PanRecognizer,\n\t        Swipe: SwipeRecognizer,\n\t        Pinch: PinchRecognizer,\n\t        Rotate: RotateRecognizer,\n\t        Press: PressRecognizer,\n\t\n\t        on: addEventListeners,\n\t        off: removeEventListeners,\n\t        each: each,\n\t        merge: merge,\n\t        extend: extend,\n\t        inherit: inherit,\n\t        bindFn: bindFn,\n\t        prefixed: prefixed\n\t    });\n\t\n\t  \n\t\n\t\n\t// $.extend(Index.prototype, Common.prototype, init: function() {\n\t\n\t// });\n\t\n\tmodule.exports = Hammer;\n\t\n\t\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar globalConfig = {};\n\t\n\tglobalConfig.Browser = {\n\t  versions: function () {\n\t    var u = navigator.userAgent, app = navigator.appVersion;\n\t    return {//移动终端浏览器版本信息\n\t      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核\n\t      mobile: !!u.match(/AppleWebKit.*Mobile.*/) || !!u.match(/AppleWebKit/), //是否为移动终端\n\t      ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端\n\t      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器\n\t      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者QQHD浏览器\n\t      iPad: u.indexOf('iPad') > -1, //是否iPad\n\t      webApp: u.indexOf('Safari') == -1, //是否web应该程序，没有头部与底部\n\t      weixin: u.toLowerCase().indexOf('micromessenger') > -1, //是否微信内置浏览器,\n\t      showjoyiOS: u.indexOf('ShowJoyiOS') > -1, // //是否iOS官方客户端内置浏览器\n\t      showjoyAndroid: u.indexOf('ShowJoyAndroid') > -1, //是否Android官方客户端内置浏览器\n\t      iOSAPP: u.indexOf('iOSAPP') > -1, // //是否iOS官方客户端内置浏览器\n\t      androidAPP: u.indexOf('androidAPP') > -1, //是否Android官方客户端内置浏览器\n\t      showjoyShopiOs: u.indexOf('showjoyshopiOS') > -1, \n\t      showjoyShopAndroid: u.indexOf('showjoyShopAndroid') > -1\n\t    };\n\t  } (),\n\t  language: (navigator.browserLanguage || navigator.language).toLowerCase()\n\t};\n\t\n\tglobalConfig.Env = (function () {\n\t  var hostname = window.location.hostname;\n\t  if ((hostname.indexOf('showjoy.net') !== -1) || (hostname.indexOf('ggl.net') !== -1)) {\n\t    return 'test';\n\t  } else if ((hostname.indexOf('showjoy.com') !== -1) || (hostname.indexOf('ggl.com') !== -1)) {\n\t    return 'alive';\n\t  }\n\t})();\n\t\n\tmodule.exports = globalConfig;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(4);\n\t__webpack_require__(5);\n\t__webpack_require__(6);\n\t\n\tvar globalConfig = __webpack_require__(2);\n\tvar isAndroid = globalConfig.Browser.versions.showjoyAndroid || globalConfig.Browser.versions.androidAPP || globalConfig.Browser.versions.showjoyShopAndroid;\n\tvar isiOS = globalConfig.Browser.versions.showjoyiOS || globalConfig.Browser.versions.iOSAPP || globalConfig.Browser.versions.showjoyShopiOs;\n\t\n\t/**\n\t * @info jsBridge,兼容oc和android\n\t */\n\tvar _jsBridge;\n\t\n\t// 保存native层调用的结果，用于js层的回调\n\tvar retFromNative, cbsAfterExecNativeMethod = [];\n\tvar messagingIframe;\n\tvar _createQueueReadyIframe = function(doc, schema) {\n\t    messagingIframe = doc.createElement('iframe');\n\t    messagingIframe.style.display = 'none';\n\t    messagingIframe.src = schema;\n\t    doc.documentElement.appendChild(messagingIframe);\n\t};\n\t\n\tvar JSBridge = {\n\t    _init: function() {\n\t        if (isiOS) {\n\t            var def = $.Deferred();\n\t\n\t            if (_jsBridge) {\n\t                setTimeout(function() {\n\t                    def.resolve(_jsBridge);\n\t                }, 0);\n\t                return def.promise();\n\t            } else {\n\t                document.addEventListener('WebViewJavascriptBridgeReady', function() {\n\t                    _jsBridge = window.WebViewJavascriptBridge;\n\t\n\t                    // 初始化jsBridge,此处不添加默认的回调函数\n\t                    // 拷贝receiveMessageQueue数组并置空\n\t                    _jsBridge.init();\n\t                    def.resolve(_jsBridge);\n\t                });\n\t                return def.promise();\n\t            }\n\t        } else if (isAndroid) {\n\t            // 安卓下无需指定特别的交互流程\n\t            // 通信依靠WebView组件,java通过loadUrl调用js函数,\n\t            // android4.4之前通过loadUrl执行js没有返回值,可通过js层调用java方法完成返回值的传递\n\t            // android4.4可通过evaluateJavascript函数执行js，并通过回调接受返回值\n\t        }\n\t    },\n\t\n\t    /**\n\t     * 注册具名方法,当native层调用具名方法时,执行该方法\n\t     * iOS通过UIWebView，Android通过WebView\n\t     *\n\t     * @param methodName 函数名\n\t     * @param method  method函数只接受一个对象,为native层传入的消息\n\t     */\n\t    registerHandler: function(methodName, method) {\n\t        var _this = this,\n\t            ret;\n\t\n\t        if (arguments.length !== 2) {\n\t            return;\n\t        }\n\t\n\t        if (_this._isDebug) {\n\t            //registerHandler methodName\n\t            _this._debugOutPut('registerHandler(regist) - methodName: ' + methodName, this._debugStyle._NORMAL_);\n\t        }\n\t\n\t        if (isiOS) {\n\t            _this._init()\n\t                .then(function(bridge) {\n\t                bridge.registerHandler(methodName, function(message, responseCallback) {\n\t\n\t                    if (_this._isDebug) {\n\t                        //registerHandler methodName\n\t                        _this._debugOutPut('registerHandler - responseData: ' + JSON.stringify(message), _this._debugStyle._NORMAL_);\n\t                    }\n\t\n\t                    ret = method(message);\n\t                    // 发送信息给oc层\n\t                    responseCallback(JSON.stringify(ret));\n\t                });\n\t            })\n\t        } else if (isAndroid) {\n\t            // 将注册的方法透出到window.javaObj的属性上\n\t            window.javaObj = window.javaObj ? window.javaObj : {};\n\t            window.javaObj[methodName] = function(message) {\n\t                if (_this._isDebug) {\n\t                    //registerHandler methodName\n\t                    _this._debugOutPut('registerHandler - responseData: ' + JSON.stringify(message), _this._debugStyle._NORMAL_);\n\t                }\n\t\n\t                //前端根据获取的参数进行方法的调用并返回内容\n\t                ret = method(JSON.stringify(message));\n\t\n\t                //针对安卓进行兼容处理，获取返回的数据\n\t                if (ret) {\n\t                    _this.callHandler('android_r_callback_data', ret, function() {});\n\t                }\n\t                // java执行js函数不返回结果，通过url传递序列化结果\n\t                // _createQueueReadyIframe(document, 'transfer://toAndroid/' + encodeURIComponent(JSON.stringify(ret)));\n\t            };\n\t        }\n\t    },\n\t    /**\n\t     * js层调用native层:iOS通过UIWebView，Android通过WebView\n\t     *\n\t     * @param methodName @type string\n\t     * @param params @type object\n\t     * @param callback @type function\n\t     */\n\t    callHandler: function(methodName, params, callback) {\n\t        if (arguments.length !== 3) {\n\t            return;\n\t        }\n\t        var _this = this,\n\t            message;\n\t\n\t        if (_this._isDebug) {\n\t            _this._debugOutPut('callHandler - methodName: ' + methodName, _this._debugStyle._NORMAL_);\n\t            _this._debugOutPut('callHandler - params: ' + JSON.stringify(params), _this._debugStyle._NORMAL_);\n\t        }\n\t\n\t        if (isiOS) {\n\t            _this._init()\n\t                .then(function(bridge) {\n\t                bridge.callHandler(methodName, params, function(message) {\n\t\n\t                    //调用app方法返回的数据\n\t                    if (_this._isDebug) {\n\t                        _this._debugOutPut('callHandeler reponse data: ' + JSON.stringify(message), _this._debugStyle._NORMAL_);\n\t                    }\n\t\n\t                    callback(message);\n\t                });\n\t            });\n\t        } else if (isAndroid) {\n\t            // java方法注入到WebView的js执行环境中\n\t            // 将注册的方法透出到window.jsObj的属性上\n\t            if (!$.isFunction(window.jsObj[methodName])) {\n\t                if (_this._isDebug) {\n\t                    _this._debugOutPut('callHandler - methodName: ' + methodName + ' 执行java方法错误,找不到该方法', _this._debugStyle._ERROR_);\n\t                }\n\t\n\t                throw new TypeError('执行java方法错误,找不到该方法');\n\t            }\n\t            try {\n\t                //TODO: 方法必须直接调用\n\t                message = window.jsObj[methodName](JSON.stringify(params));\n\t\n\t                //调用app方法返回的数据\n\t                if (_this._isDebug) {\n\t                    _this._debugOutPut('callHandeler reponse data: ' + JSON.stringify(message), _this._debugStyle._NORMAL_);\n\t                }\n\t\n\t            } catch (e) {\n\t                if (_this._isDebug) {\n\t                    console.log(e);\n\t                    console.log('java方法执行出错');\n\t                    _this._debugOutPut('callHandler: ' + methodName + ' ' + e, _this._debugStyle._ERROR_);\n\t                    _this._debugOutPut('callHandler: java方法执行出错 ' + methodName, _this._debugStyle._ERROR_);\n\t                }\n\t                return;\n\t            }\n\t            callback(message);\n\t        }\n\t    },\n\t    /**\n\t     * 调用本地方法\n\t     * @param className    required\n\t     * @param method    required\n\t     * @param params @type 数组    options\n\t     * @param cb @type 函数    options\n\t     */\n\t    executeNativeMethod: function(className, method, params, cb) {\n\t        var _this = this;\n\t        if (arguments.length < 2 || arguments.length > 4) {\n\t\n\t            if (_this._isDebug) {\n\t                _this._debugOutPut('调用参数个数应该为w-4个，分别为className,method,params以及可选的cb回调', _this._debugStyle._ERROR_);\n\t            }\n\t\n\t            throw new EvalError('调用参数个数应该为w-4个，分别为className,method,params以及可选的cb回调');\n\t        }\n\t        if (typeof className !== 'string') {\n\t\n\t            if (_this._isDebug) {\n\t                _this._debugOutPut('className类型错误', _this._debugStyle._ERROR_);\n\t            }\n\t\n\t            throw new TypeError('className类型错误');\n\t        }\n\t        if (typeof method !== 'string') {\n\t\n\t            if (_this._isDebug) {\n\t                _this._debugOutPut('method类型错误', _this._debugStyle._ERROR_);\n\t            }\n\t\n\t            throw new TypeError('method类型错误');\n\t        }\n\t        if (!params) {\n\t            params = [];\n\t        } else if (params && !cb && {}.toString.call(params) !== '[object Array]') {\n\t            if (typeof params !== 'function') {\n\t                throw new TypeError('params应为数组');\n\t            } else {\n\t                cb = params;\n\t                params = [];\n\t            }\n\t        } else if (cb) {\n\t            if (typeof cb !== 'function') {\n\t                throw new TypeError('cb类型错误');\n\t            }\n\t        }\n\t\n\t        cb && cbsAfterExecNativeMethod.push(cb);\n\t        var ret, fnCode, i, len, str;\n\t        try {\n\t            // 1,无法使用call，apply方式调用oc本地方法\n\t            // ret = window[className][method].apply(null,params);\n\t            // 2,无法间接调用\n\t            // fn ＝ window[className][method];fn();\n\t\n\t            fnCode = 'window[className][method](';\n\t            for (i = 0, len = params.length; i < len; i++) {\n\t                if (typeof params[i] == 'string') {\n\t                    str = \"\\'\" + params[i] + \"\\'\";\n\t                } else {\n\t                    str = params[i];\n\t                }\n\t                if (i < len - 1) {\n\t                    fnCode += str + ',';\n\t                } else {\n\t                    fnCode += str + ')';\n\t                }\n\t            }\n\t            eval(fnCode);\n\t\n\t        } catch (e) {\n\t            cb && cb(e);\n\t            cbsAfterExecNativeMethod = [];\n\t        }\n\t    },\n\t    /**\n\t     * 注册js函数，与registerHandler的区别仅仅在于iOS层实现的不同\n\t     * iOS抛弃使用webViewJavaScriptBridge框架，该用JSC引擎通信\n\t     *\n\t     * @param methodName 函数名\n\t     * @param method  method函数只接受一个对象,为native层传入的消息\n\t     */\n\t    registerJSMethod: function(methodName, method) {\n\t        var isiOS4JSC = $.JSBridge.isiOS4JSC;\n\t        if (isiOS4JSC) {\n\t            // 将注册的方法透出到window.jscObj的属性上\n\t            var ev = eval;\n\t            $.JSBridge._JSMethod = method;\n\t\n\t            // 暴露函数至全局\n\t            // jsc只能执行全局函数声明方式定义的函数，不可以将函数指针复制给其他变量执行\n\t            ev('function toObjectCExec() {' + 'window.jscObj = window.jscObj ? window.jscObj : {};' + 'window.jscObj[\"' + methodName + '\"] = function (message) {' + '  var ret = $.JSBridge._JSMethod(message);' + '  return JSON.stringify(ret);' + '};' + 'return jscObj;' + '}');\n\t\n\t        } else if (isAndroid) {\n\t            // 将注册的方法透出到window.javaObj的属性上\n\t            window.javaObj = window.javaObj ? window.javaObj : {};\n\t            window.javaObj[methodName] = function(message) {\n\t                var ret = method(message);\n\t\n\t                // java执行js函数不返回结果，通过url传递序列化结果\n\t                _createQueueReadyIframe(document, 'transfer://toAndroid/' + encodeURIComponent(JSON.stringify(ret)));\n\t            };\n\t        }\n\t\n\t    },\n\t    _transResultFromNative: function(ret) {\n\t        retFromNative = ret;\n\t        var cbs = cbsAfterExecNativeMethod;\n\t        cbsAfterExecNativeMethod = [];\n\t        for (var i = 0, len = cbs.length; i < len; i++) {\n\t            cbs[i](null, ret);\n\t        }\n\t    },\n\t    /**\n\t     * 测试环境进行debug信息的展示\n\t     */\n\t    _isDebug: false,\n\t    // 判断测试环境\n\t    _isTest: (function() {\n\t        if (globalConfig.Env === 'test') {\n\t            return true;\n\t        } else {\n\t            return false;\n\t        }\n\t    })(),\n\t    setDebug: function(bool) {\n\t        var _this = this;\n\t        if (bool) {\n\t            _this._isDebug = true;\n\t            if (_this._isTest) {\n\t                _this._debugShow();\n\t            }\n\t        } else {\n\t            _this._isDebug = false;\n\t        }\n\t    },\n\t    _debugShow: function() {\n\t        var _this = this;\n\t\n\t        function _debugBlockInit() {\n\t            var debugBlock = '<div class=\"webview-btn j_WebviewDebugBtn\">debug</div>' + '<div class=\"webview-console j_WebviewConsole\"><div class=\"pannel j_WebviewPannel\"></div></div>';\n\t            $('body').append(debugBlock);\n\t        }\n\t\n\t        function _eventBind() {\n\t            var $webviewConsole = $('.j_WebviewConsole');\n\t            $(document).on('click', '.j_WebviewDebugBtn', function() {\n\t                if ($webviewConsole.hasClass('show')) {\n\t                    $webviewConsole.removeClass('show');\n\t                } else {\n\t                    $webviewConsole.addClass('show');\n\t                }\n\t            })\n\t        }\n\t\n\t        function _initDebugFunction() {\n\t            if (isAndroid) {\n\t                _this._debugOutPut('env: showjoy Android app', _this._debugStyle._NORMAL_);\n\t            } else if (isiOS) {\n\t                _this._debugOutPut('env: showjoy IOS app', _this._debugStyle._NORMAL_);\n\t            }\n\t        }\n\t\n\t        if (isAndroid || isiOS) {\n\t            _debugBlockInit();\n\t            _eventBind();\n\t            _initDebugFunction();\n\t        }\n\t    },\n\t    _debugStyle: {\n\t        _NORMAL_: 'normal',\n\t        _WARNING_: 'warn',\n\t        _ERROR_: 'error',\n\t    },\n\t    _debugOutPut: function(content, style) {\n\t        if (this._isDebug) {\n\t            var $consolePannel = $('.j_WebviewPannel');\n\t            $consolePannel.append('<p class=\"' + style + '\">' + content + '</p>');\n\t        }\n\t    }\n\t};\n\t\n\tJSBridge._init();\n\t\n\t// 暴露方法到全局命名空间\n\t$.JSBridge = JSBridge; \n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t//  模块外面不用包一层define，dev和build时工具会自动加上，遵循CommonJS规范，像node一样写就可以了，如下\n\t'use strict';\n\t\n\t$.Callbacks = function(options) {\n\t  options = $.extend({}, options)\n\t\n\t  var memory, // Last fire value (for non-forgettable lists)\n\t    fired,  // Flag to know if list was already fired\n\t    firing, // Flag to know if list is currently firing\n\t    firingStart, // First callback to fire (used internally by add and fireWith)\n\t    firingLength, // End of the loop when firing\n\t    firingIndex, // Index of currently firing callback (modified by remove if needed)\n\t    list = [], // Actual callback list\n\t    stack = !options.once && [], // Stack of fire calls for repeatable lists\n\t    fire = function(data) {\n\t      memory = options.memory && data\n\t      fired = true\n\t      firingIndex = firingStart || 0\n\t      firingStart = 0\n\t      firingLength = list.length\n\t      firing = true\n\t      for ( ; list && firingIndex < firingLength ; ++firingIndex ) {\n\t        if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {\n\t          memory = false\n\t          break\n\t        }\n\t      }\n\t      firing = false\n\t      if (list) {\n\t        if (stack) stack.length && fire(stack.shift())\n\t        else if (memory) list.length = 0\n\t        else Callbacks.disable()\n\t      }\n\t    },\n\t\n\t    Callbacks = {\n\t      add: function() {\n\t        if (list) {\n\t          var start = list.length,\n\t            add = function(args) {\n\t              $.each(args, function(_, arg){\n\t                if (typeof arg === \"function\") {\n\t                  if (!options.unique || !Callbacks.has(arg)) list.push(arg)\n\t                }\n\t                else if (arg && arg.length && typeof arg !== 'string') add(arg)\n\t              })\n\t            }\n\t          add(arguments)\n\t          if (firing) firingLength = list.length\n\t          else if (memory) {\n\t            firingStart = start\n\t            fire(memory)\n\t          }\n\t        }\n\t        return this\n\t      },\n\t      remove: function() {\n\t        if (list) {\n\t          $.each(arguments, function(_, arg){\n\t            var index\n\t            while ((index = $.inArray(arg, list, index)) > -1) {\n\t              list.splice(index, 1)\n\t              // Handle firing indexes\n\t              if (firing) {\n\t                if (index <= firingLength) --firingLength\n\t                if (index <= firingIndex) --firingIndex\n\t              }\n\t            }\n\t          })\n\t        }\n\t        return this\n\t      },\n\t      has: function(fn) {\n\t        return !!(list && (fn ? $.inArray(fn, list) > -1 : list.length))\n\t      },\n\t      empty: function() {\n\t        firingLength = list.length = 0\n\t        return this\n\t      },\n\t      disable: function() {\n\t        list = stack = memory = undefined\n\t        return this\n\t      },\n\t      disabled: function() {\n\t        return !list\n\t      },\n\t      lock: function() {\n\t        stack = undefined;\n\t        if (!memory) Callbacks.disable()\n\t        return this\n\t      },\n\t      locked: function() {\n\t        return !stack\n\t      },\n\t      fireWith: function(context, args) {\n\t        if (list && (!fired || stack)) {\n\t          args = args || []\n\t          args = [context, args.slice ? args.slice() : args]\n\t          if (firing) stack.push(args)\n\t          else fire(args)\n\t        }\n\t        return this\n\t      },\n\t      fire: function() {\n\t        return Callbacks.fireWith(this, arguments)\n\t      },\n\t      fired: function() {\n\t        return !!fired\n\t      }\n\t    }\n\t\n\t  return Callbacks\n\t\n\t}\n\t\n\t\n\t\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t//  模块外面不用包一层define，dev和build时工具会自动加上，遵循CommonJS规范，像node一样写就可以了，如下\n\t\n\t'use strict';\n\t\n\t\n\tvar slice = Array.prototype.slice\n\t\n\tfunction Deferred(func) {\n\t  var tuples = [\n\t      // action, add listener, listener list, final state\n\t      [ \"resolve\", \"done\", $.Callbacks({once:1, memory:1}), \"resolved\" ],\n\t      [ \"reject\", \"fail\", $.Callbacks({once:1, memory:1}), \"rejected\" ],\n\t      [ \"notify\", \"progress\", $.Callbacks({memory:1}) ]\n\t    ],\n\t    state = \"pending\",\n\t    promise = {\n\t      state: function() {\n\t        return state\n\t      },\n\t      always: function() {\n\t        deferred.done(arguments).fail(arguments)\n\t        return this\n\t      },\n\t      then: function(/* fnDone [, fnFailed [, fnProgress]] */) {\n\t        var fns = arguments\n\t        return Deferred(function(defer){\n\t          $.each(tuples, function(i, tuple){\n\t            var fn = $.isFunction(fns[i]) && fns[i]\n\t            deferred[tuple[1]](function(){\n\t              var returned = fn && fn.apply(this, arguments)\n\t              if (returned && $.isFunction(returned.promise)) {\n\t                returned.promise()\n\t                  .done(defer.resolve)\n\t                  .fail(defer.reject)\n\t                  .progress(defer.notify)\n\t              } else {\n\t                var context = this === promise ? defer.promise() : this,\n\t                  values = fn ? [returned] : arguments\n\t                defer[tuple[0] + \"With\"](context, values)\n\t              }\n\t            })\n\t          })\n\t          fns = null\n\t        }).promise()\n\t      },\n\t\n\t      promise: function(obj) {\n\t        return obj != null ? $.extend( obj, promise ) : promise\n\t      }\n\t    },\n\t    deferred = {}\n\t\n\t  $.each(tuples, function(i, tuple){\n\t    var list = tuple[2],\n\t      stateString = tuple[3]\n\t\n\t    promise[tuple[1]] = list.add\n\t\n\t    if (stateString) {\n\t      list.add(function(){\n\t        state = stateString\n\t      }, tuples[i^1][2].disable, tuples[2][2].lock)\n\t    }\n\t\n\t    deferred[tuple[0]] = function(){\n\t      deferred[tuple[0] + \"With\"](this === deferred ? promise : this, arguments)\n\t      return this\n\t    }\n\t    deferred[tuple[0] + \"With\"] = list.fireWith\n\t  })\n\t\n\t  promise.promise(deferred)\n\t  if (func) func.call(deferred, deferred)\n\t  return deferred\n\t}\n\t\n\t$.when = function(sub) {\n\t  var resolveValues = slice.call(arguments),\n\t    len = resolveValues.length,\n\t    i = 0,\n\t    remain = len !== 1 || (sub && $.isFunction(sub.promise)) ? len : 0,\n\t    deferred = remain === 1 ? sub : Deferred(),\n\t    progressValues, progressContexts, resolveContexts,\n\t    updateFn = function(i, ctx, val){\n\t      return function(value){\n\t        ctx[i] = this\n\t        val[i] = arguments.length > 1 ? slice.call(arguments) : value\n\t        if (val === progressValues) {\n\t          deferred.notifyWith(ctx, val)\n\t        } else if (!(--remain)) {\n\t          deferred.resolveWith(ctx, val)\n\t        }\n\t      }\n\t    }\n\t\n\t  if (len > 1) {\n\t    progressValues = new Array(len)\n\t    progressContexts = new Array(len)\n\t    resolveContexts = new Array(len)\n\t    for ( ; i < len; ++i ) {\n\t      if (resolveValues[i] && $.isFunction(resolveValues[i].promise)) {\n\t        resolveValues[i].promise()\n\t          .done(updateFn(i, resolveContexts, resolveValues))\n\t          .fail(deferred.reject)\n\t          .progress(updateFn(i, progressContexts, progressValues))\n\t      } else {\n\t        --remain\n\t      }\n\t    }\n\t  }\n\t  if (!remain) deferred.resolveWith(resolveContexts, resolveValues)\n\t  return deferred.promise()\n\t}\n\t\n\t$.Deferred = Deferred;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(7);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(9)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../../../../../usr/local/lib/node_modules/spon/node_modules/css-loader/index.js!./../../../../../../../usr/local/lib/node_modules/spon/node_modules/less-loader/index.js!./js-debug.less\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../../../../../usr/local/lib/node_modules/spon/node_modules/css-loader/index.js!./../../../../../../../usr/local/lib/node_modules/spon/node_modules/less-loader/index.js!./js-debug.less\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(8)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".webview-btn{position:fixed;top:55%;left:0;width:50px;height:50px;opacity:.5;background-color:#000;color:#fff;font:13px/50px Arial;border-radius:25px;text-align:center}.webview-console{display:none;position:fixed;top:0;left:0;z-index:1000;width:100%;height:200px;overflow-y:scroll;background-color:#fff;padding:10px}.webview-console .pannel{width:100%;height:auto}.webview-console .pannel p{width:100%;height:auto;margin-bottom:5px;font:13px/14px Helvetica Neue}.webview-console .pannel .normal{color:#000}.webview-console .pannel .warn{color:orange}.webview-console .pannel .error{color:red}.webview-console.show{display:block}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0,\r\n\t\tstyleElementsInsertedAtTop = [];\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(false) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\t// By default, add <style> tags to the bottom of <head>.\r\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction insertStyleElement(options, styleElement) {\r\n\t\tvar head = getHeadElement();\r\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\t\tif (options.insertAt === \"top\") {\r\n\t\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t\t} else {\r\n\t\t\t\thead.appendChild(styleElement);\r\n\t\t\t}\r\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t\t} else if (options.insertAt === \"bottom\") {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction removeStyleElement(styleElement) {\r\n\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\t\tif(idx >= 0) {\r\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction createStyleElement(options) {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\tinsertStyleElement(options, styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement(options) {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\tinsertStyleElement(options, linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement(options);\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement(options);\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\t// http://stackoverflow.com/a/26603875\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** src/pages/item-pic/item-pic.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d952d7c1de0e6ff23822\n **/","'use strict';\n\nvar Hammer = require('fecomponent/mobi-hammer');\nvar globalConfig = require('fecomponent/mobi-detect-ua');\nrequire('fecomponent/mobi-jswebview');\n\n$(function () {\n  if(globalConfig.Browser.versions.showjoyShopiOs || globalConfig.Browser.versions.showjoyShopAndroid) {\n    $('.j_ItemPic').on('click', function() {\n      var imgIndex = $(this).index();\n      $.JSBridge.callHandler('shopc_show_imgLists', {\n        index: imgIndex\n      }, function () { });\n    });\n  } else {\n    var stateMap = {\n      scale: 1,\n      position: {\n        x: 0,\n        y: 0\n      }\n    };\n\n    var transform = '';\n\n    var setTransform = function () {\n      var arr = transform.split(/\\)\\s/);\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i].search(/scale/) !== -1) {\n          stateMap.scale = arr[i].match(/\\d+(\\.\\d+)?/)[0];\n        } else if (arr[i].search(/translate/) !== -1) {\n          stateMap.position.x = arr[i].match(/\\-?\\d+px/g)[0].match(/\\-?\\d+/);\n          stateMap.position.y = arr[i].match(/\\-?\\d+px/g)[1].match(/\\-?\\d+/);\n        }\n      }\n    }\n    var showBox = function (ev) {\n      if (ev.target.nodeName === 'IMG') {\n        $('.j_BoxDescriptionImg').show();\n        var src = ev.target.src;\n        $('.j_BoxDescriptionImg').find('img').attr('src', src);\n      }\n    }\n    var hideWrap = function (ev) {\n      ev.preventDefault();\n      $('.j_BoxDescriptionImg').hide();\n      $('.j_Img').css({\n        '-webkit-transform': 'scale(1)',\n        'transform': 'scale(1)'\n      });\n      stateMap.scale = 1;\n      stateMap.position.x = 0;\n      stateMap.position.y = 0;\n    };\n    var scaleImg = function (ev) {\n      $('.j_Img').css({\n        '-webkit-transform': 'scale(' + (stateMap.scale * ev.scale) + ')' + '  translate3d(' + \n          (stateMap.position.x) + 'px,' + (stateMap.position.y) + 'px, 0px)',\n        'transform': 'scale(' + (stateMap.scale * ev.scale) + ')' + '  translate3d(' + \n          (stateMap.position.x) + 'px,' + (stateMap.position.y) + 'px, 0px)'\n      });\n    }\n    var scaleEndImg = function () {\n      transform = $('.j_Img').css('-webkit-transform') === \n        null ? ('.j_Img').css('-webkit-transform') : $('.j_Img').css('-webkit-transform');\n      setTransform();\n      if (stateMap.scale < 1) {\n        $('.j_Img').css({\n          '-webkit-transform': 'scale(1)',\n          'transform': 'scale(1)'\n        });\n        stateMap.scale = 1;\n        stateMap.position.x = 0;\n        stateMap.position.y = 0;\n      }\n    };\n\n    var moveImg = function (ev) {\n      if (stateMap.scale > 1) {\n        $('.j_Img').css({\n          '-webkit-transform': 'scale(' + (stateMap.scale) + ')' + ' translate3d(' + \n            parseFloat(parseFloat(stateMap.position.x) + parseFloat(ev.deltaX)) + 'px,' + \n            parseFloat(parseFloat(stateMap.position.y) + parseFloat(ev.deltaY)) + 'px, 0px)',\n          'transform': 'scale(' + (stateMap.scale) + ')' + ' translate3d(' + \n            parseFloat(parseFloat(stateMap.position.x) + parseFloat(ev.deltaX)) + 'px,' + \n            parseFloat(parseFloat(stateMap.position.y) + parseFloat(ev.deltaY)) + 'px, 0px)'\n        });\n      }\n    }\n    var moveEndImg = function () {\n      transform = $('.j_Img').css('-webkit-transform') === \n        null ? ('.j_Img').css('-webkit-transform') : $('.j_Img').css('-webkit-transform');\n      setTransform();\n    };\n    var wrap = $('.j_BoxDescriptionImg')[0];\n    var wrapHammer = new Hammer(wrap);\n    var singletap = new Hammer.Tap();\n    var doubletap = new Hammer.Tap({ event: 'doubletap', taps: 2 });\n    var pinch = new Hammer.Pinch();\n    var pan = new Hammer.Pan();\n\n    wrapHammer.add(singletap);\n    wrapHammer.add(doubletap);\n    singletap.requireFailure(doubletap);\n    doubletap.requireFailure(singletap);\n    wrapHammer.add(pinch);\n    wrapHammer.add(pan);\n\n    wrapHammer.on('tap', hideWrap);\n    wrapHammer.on('pinchmove', scaleImg);\n    wrapHammer.on('pinchend', scaleEndImg);\n    wrapHammer.on('panmove', moveImg);\n    wrapHammer.on('panend', moveEndImg);\n\n    var img = $('.j_Box2')[0];\n    var imgHammer = new Hammer(img);\n    imgHammer.on('tap', showBox);\n  }\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/pages/item-pic/item-pic.js\n ** module id = 0\n ** module chunks = 0\n **/","//  模块外面不用包一层define，dev和build时工具会自动加上，遵循CommonJS规范，像node一样写就可以了，如下\n\n'use strict';\n\n\n// 支持在项目文件中使用基于src根目录下的绝对路径\n// var Common = require('components/abc/abc');\n// 使用 fecomponent 组件\n// var say = require('fecomponent/mobi-say');\n\n/*! Hammer.JS - v2.0.4 - 2014-09-28\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2014 Jorik Tangelder;\n * Licensed under the MIT license */ \n\n\n    var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\n    var TEST_ELEMENT = document.createElement('div');\n\n    var TYPE_FUNCTION = 'function';\n\n    var round = Math.round;\n    var abs = Math.abs;\n    var now = Date.now;\n\n    /**\n     * set a timeout with a given scope\n     * @param {Function} fn\n     * @param {Number} timeout\n     * @param {Object} context\n     * @returns {number}\n     */\n    function setTimeoutContext(fn, timeout, context) {\n        return setTimeout(bindFn(fn, context), timeout);\n    }\n\n    /**\n     * if the argument is an array, we want to execute the fn on each entry\n     * if it aint an array we don't want to do a thing.\n     * this is used by all the methods that accept a single and array argument.\n     * @param {*|Array} arg\n     * @param {String} fn\n     * @param {Object} [context]\n     * @returns {Boolean}\n     */\n    function invokeArrayArg(arg, fn, context) {\n        if (Array.isArray(arg)) {\n            each(arg, context[fn], context);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * walk objects and arrays\n     * @param {Object} obj\n     * @param {Function} iterator\n     * @param {Object} context\n     */\n    function each(obj, iterator, context) {\n        var i;\n\n        if (!obj) {\n            return;\n        }\n\n        if (obj.forEach) {\n            obj.forEach(iterator, context);\n        } else if (obj.length !== undefined) {\n            i = 0;\n            while (i < obj.length) {\n                iterator.call(context, obj[i], i, obj);\n                i++;\n            }\n        } else {\n            for (i in obj) {\n                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n            }\n        }\n    }\n\n    /**\n     * extend object.\n     * means that properties in dest will be overwritten by the ones in src.\n     * @param {Object} dest\n     * @param {Object} src\n     * @param {Boolean} [merge]\n     * @returns {Object} dest\n     */\n    function extend(dest, src, merge) {\n        var keys = Object.keys(src);\n        var i = 0;\n        while (i < keys.length) {\n            if (!merge || (merge && dest[keys[i]] === undefined)) {\n                dest[keys[i]] = src[keys[i]];\n            }\n            i++;\n        }\n        return dest;\n    }\n\n    /**\n     * merge the values from src in the dest.\n     * means that properties that exist in dest will not be overwritten by src\n     * @param {Object} dest\n     * @param {Object} src\n     * @returns {Object} dest\n     */\n    function merge(dest, src) {\n        return extend(dest, src, true);\n    }\n\n    /**\n     * simple class inheritance\n     * @param {Function} child\n     * @param {Function} base\n     * @param {Object} [properties]\n     */\n    function inherit(child, base, properties) {\n        var baseP = base.prototype,\n            childP;\n\n        childP = child.prototype = Object.create(baseP);\n        childP.constructor = child;\n        childP._super = baseP;\n\n        if (properties) {\n            extend(childP, properties);\n        }\n    }\n\n    /**\n     * simple function bind\n     * @param {Function} fn\n     * @param {Object} context\n     * @returns {Function}\n     */\n    function bindFn(fn, context) {\n        return function boundFn() {\n            return fn.apply(context, arguments);\n        };\n    }\n\n    /**\n     * let a boolean value also be a function that must return a boolean\n     * this first item in args will be used as the context\n     * @param {Boolean|Function} val\n     * @param {Array} [args]\n     * @returns {Boolean}\n     */\n    function boolOrFn(val, args) {\n        if (typeof val == TYPE_FUNCTION) {\n            return val.apply(args ? args[0] || undefined : undefined, args);\n        }\n        return val;\n    }\n\n    /**\n     * use the val2 when val1 is undefined\n     * @param {*} val1\n     * @param {*} val2\n     * @returns {*}\n     */\n    function ifUndefined(val1, val2) {\n        return (val1 === undefined) ? val2 : val1;\n    }\n\n    /**\n     * addEventListener with multiple events at once\n     * @param {EventTarget} target\n     * @param {String} types\n     * @param {Function} handler\n     */\n    function addEventListeners(target, types, handler) {\n        each(splitStr(types), function(type) {\n            target.addEventListener(type, handler, false);\n        });\n    }\n\n    /**\n     * removeEventListener with multiple events at once\n     * @param {EventTarget} target\n     * @param {String} types\n     * @param {Function} handler\n     */\n    function removeEventListeners(target, types, handler) {\n        each(splitStr(types), function(type) {\n            target.removeEventListener(type, handler, false);\n        });\n    }\n\n    /**\n     * find if a node is in the given parent\n     * @method hasParent\n     * @param {HTMLElement} node\n     * @param {HTMLElement} parent\n     * @return {Boolean} found\n     */\n    function hasParent(node, parent) {\n        while (node) {\n            if (node == parent) {\n                return true;\n            }\n            node = node.parentNode;\n        }\n        return false;\n    }\n\n    /**\n     * small indexOf wrapper\n     * @param {String} str\n     * @param {String} find\n     * @returns {Boolean} found\n     */\n    function inStr(str, find) {\n        return str.indexOf(find) > -1;\n    }\n\n    /**\n     * split string on whitespace\n     * @param {String} str\n     * @returns {Array} words\n     */\n    function splitStr(str) {\n        return str.trim().split(/\\s+/g);\n    }\n\n    /**\n     * find if a array contains the object using indexOf or a simple polyFill\n     * @param {Array} src\n     * @param {String} find\n     * @param {String} [findByKey]\n     * @return {Boolean|Number} false when not found, or the index\n     */\n    function inArray(src, find, findByKey) {\n        if (src.indexOf && !findByKey) {\n            return src.indexOf(find);\n        } else {\n            var i = 0;\n            while (i < src.length) {\n                if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                    return i;\n                }\n                i++;\n            }\n            return -1;\n        }\n    }\n\n    /**\n     * convert array-like objects to real arrays\n     * @param {Object} obj\n     * @returns {Array}\n     */\n    function toArray(obj) {\n        return Array.prototype.slice.call(obj, 0);\n    }\n\n    /**\n     * unique array with objects based on a key (like 'id') or just by the array's value\n     * @param {Array} src [{id:1},{id:2},{id:1}]\n     * @param {String} [key]\n     * @param {Boolean} [sort=False]\n     * @returns {Array} [{id:1},{id:2}]\n     */\n    function uniqueArray(src, key, sort) {\n        var results = [];\n        var values = [];\n        var i = 0;\n\n        while (i < src.length) {\n            var val = key ? src[i][key] : src[i];\n            if (inArray(values, val) < 0) {\n                results.push(src[i]);\n            }\n            values[i] = val;\n            i++;\n        }\n\n        if (sort) {\n            if (!key) {\n                results = results.sort();\n            } else {\n                results = results.sort(function sortUniqueArray(a, b) {\n                    return a[key] > b[key];\n                });\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     * get the prefixed property\n     * @param {Object} obj\n     * @param {String} property\n     * @returns {String|Undefined} prefixed\n     */\n    function prefixed(obj, property) {\n        var prefix, prop;\n        var camelProp = property[0].toUpperCase() + property.slice(1);\n\n        var i = 0;\n        while (i < VENDOR_PREFIXES.length) {\n            prefix = VENDOR_PREFIXES[i];\n            prop = (prefix) ? prefix + camelProp : property;\n\n            if (prop in obj) {\n                return prop;\n            }\n            i++;\n        }\n        return undefined;\n    }\n\n    /**\n     * get a unique id\n     * @returns {number} uniqueId\n     */\n    var _uniqueId = 1;\n\n    function uniqueId() {\n        return _uniqueId++;\n    }\n\n    /**\n     * get the window object of an element\n     * @param {HTMLElement} element\n     * @returns {DocumentView|Window}\n     */\n    function getWindowForElement(element) {\n        var doc = element.ownerDocument;\n        return (doc.defaultView || doc.parentWindow);\n    }\n\n    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\n    var SUPPORT_TOUCH = ('ontouchstart' in window);\n    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\n    var INPUT_TYPE_TOUCH = 'touch';\n    var INPUT_TYPE_PEN = 'pen';\n    var INPUT_TYPE_MOUSE = 'mouse';\n    var INPUT_TYPE_KINECT = 'kinect';\n\n    var COMPUTE_INTERVAL = 25;\n\n    var INPUT_START = 1;\n    var INPUT_MOVE = 2;\n    var INPUT_END = 4;\n    var INPUT_CANCEL = 8;\n\n    var DIRECTION_NONE = 1;\n    var DIRECTION_LEFT = 2;\n    var DIRECTION_RIGHT = 4;\n    var DIRECTION_UP = 8;\n    var DIRECTION_DOWN = 16;\n\n    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\n    var PROPS_XY = ['x', 'y'];\n    var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n    /**\n     * create new input type manager\n     * @param {Manager} manager\n     * @param {Function} callback\n     * @returns {Input}\n     * @constructor\n     */\n    function Input(manager, callback) {\n        var self = this;\n        this.manager = manager;\n        this.callback = callback;\n        this.element = manager.element;\n        this.target = manager.options.inputTarget;\n\n        // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n        // so when disabled the input events are completely bypassed.\n        this.domHandler = function(ev) {\n            if (boolOrFn(manager.options.enable, [manager])) {\n                self.handler(ev);\n            }\n        };\n\n        this.init();\n\n    }\n\n    Input.prototype = {\n        /**\n         * should handle the inputEvent data and trigger the callback\n         * @virtual\n         */\n        handler: function() {},\n\n        /**\n         * bind the events\n         */\n        init: function() {\n            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n        },\n\n        /**\n         * unbind the events\n         */\n        destroy: function() {\n            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n        }\n    };\n\n    /**\n     * create new input type manager\n     * called by the Manager constructor\n     * @param {Hammer} manager\n     * @returns {Input}\n     */\n    function createInputInstance(manager) {\n        var Type;\n        var inputClass = manager.options.inputClass;\n\n        if (inputClass) {\n            Type = inputClass;\n        } else if (SUPPORT_POINTER_EVENTS) {\n            Type = PointerEventInput;\n        } else if (SUPPORT_ONLY_TOUCH) {\n            Type = TouchInput;\n        } else if (!SUPPORT_TOUCH) {\n            Type = MouseInput;\n        } else {\n            Type = TouchMouseInput;\n        }\n        return new(Type)(manager, inputHandler);\n    }\n\n    /**\n     * handle input events\n     * @param {Manager} manager\n     * @param {String} eventType\n     * @param {Object} input\n     */\n    function inputHandler(manager, eventType, input) {\n        var pointersLen = input.pointers.length;\n        var changedPointersLen = input.changedPointers.length;\n        var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n        var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n        input.isFirst = !! isFirst;\n        input.isFinal = !! isFinal;\n\n        if (isFirst) {\n            manager.session = {};\n        }\n\n        // source event is the normalized value of the domEvents\n        // like 'touchstart, mouseup, pointerdown'\n        input.eventType = eventType;\n\n        // compute scale, rotation etc\n        computeInputData(manager, input);\n\n        // emit secret event\n        manager.emit('hammer.input', input);\n\n        manager.recognize(input);\n        manager.session.prevInput = input;\n    }\n\n    /**\n     * extend the data with some usable properties like scale, rotate, velocity etc\n     * @param {Object} manager\n     * @param {Object} input\n     */\n    function computeInputData(manager, input) {\n        var session = manager.session;\n        var pointers = input.pointers;\n        var pointersLength = pointers.length;\n\n        // store the first input to calculate the distance and direction\n        if (!session.firstInput) {\n            session.firstInput = simpleCloneInputData(input);\n        }\n\n        // to compute scale and rotation we need to store the multiple touches\n        if (pointersLength > 1 && !session.firstMultiple) {\n            session.firstMultiple = simpleCloneInputData(input);\n        } else if (pointersLength === 1) {\n            session.firstMultiple = false;\n        }\n\n        var firstInput = session.firstInput;\n        var firstMultiple = session.firstMultiple;\n        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n        var center = input.center = getCenter(pointers);\n        input.timeStamp = now();\n        input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n        input.angle = getAngle(offsetCenter, center);\n        input.distance = getDistance(offsetCenter, center);\n\n        computeDeltaXY(session, input);\n        input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n        computeIntervalInputData(session, input);\n\n        // find the correct target\n        var target = manager.element;\n        if (hasParent(input.srcEvent.target, target)) {\n            target = input.srcEvent.target;\n        }\n        input.target = target;\n    }\n\n    function computeDeltaXY(session, input) {\n        var center = input.center;\n        var offset = session.offsetDelta || {};\n        var prevDelta = session.prevDelta || {};\n        var prevInput = session.prevInput || {};\n\n        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n            prevDelta = session.prevDelta = {\n                x: prevInput.deltaX || 0,\n                y: prevInput.deltaY || 0\n            };\n\n            offset = session.offsetDelta = {\n                x: center.x,\n                y: center.y\n            };\n        }\n\n        input.deltaX = prevDelta.x + (center.x - offset.x);\n        input.deltaY = prevDelta.y + (center.y - offset.y);\n    }\n\n    /**\n     * velocity is calculated every x ms\n     * @param {Object} session\n     * @param {Object} input\n     */\n    function computeIntervalInputData(session, input) {\n        var last = session.lastInterval || input,\n            deltaTime = input.timeStamp - last.timeStamp,\n            velocity, velocityX, velocityY, direction;\n\n        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n            var deltaX = last.deltaX - input.deltaX;\n            var deltaY = last.deltaY - input.deltaY;\n\n            var v = getVelocity(deltaTime, deltaX, deltaY);\n            velocityX = v.x;\n            velocityY = v.y;\n            velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n            direction = getDirection(deltaX, deltaY);\n\n            session.lastInterval = input;\n        } else {\n            // use latest velocity info if it doesn't overtake a minimum period\n            velocity = last.velocity;\n            velocityX = last.velocityX;\n            velocityY = last.velocityY;\n            direction = last.direction;\n        }\n\n        input.velocity = velocity;\n        input.velocityX = velocityX;\n        input.velocityY = velocityY;\n        input.direction = direction;\n    }\n\n    /**\n     * create a simple clone from the input used for storage of firstInput and firstMultiple\n     * @param {Object} input\n     * @returns {Object} clonedInputData\n     */\n    function simpleCloneInputData(input) {\n        // make a simple copy of the pointers because we will get a reference if we don't\n        // we only need clientXY for the calculations\n        var pointers = [];\n        var i = 0;\n        while (i < input.pointers.length) {\n            pointers[i] = {\n                clientX: round(input.pointers[i].clientX),\n                clientY: round(input.pointers[i].clientY)\n            };\n            i++;\n        }\n\n        return {\n            timeStamp: now(),\n            pointers: pointers,\n            center: getCenter(pointers),\n            deltaX: input.deltaX,\n            deltaY: input.deltaY\n        };\n    }\n\n    /**\n     * get the center of all the pointers\n     * @param {Array} pointers\n     * @return {Object} center contains `x` and `y` properties\n     */\n    function getCenter(pointers) {\n        var pointersLength = pointers.length;\n\n        // no need to loop when only one touch\n        if (pointersLength === 1) {\n            return {\n                x: round(pointers[0].clientX),\n                y: round(pointers[0].clientY)\n            };\n        }\n\n        var x = 0,\n            y = 0,\n            i = 0;\n        while (i < pointersLength) {\n            x += pointers[i].clientX;\n            y += pointers[i].clientY;\n            i++;\n        }\n\n        return {\n            x: round(x / pointersLength),\n            y: round(y / pointersLength)\n        };\n    }\n\n    /**\n     * calculate the velocity between two points. unit is in px per ms.\n     * @param {Number} deltaTime\n     * @param {Number} x\n     * @param {Number} y\n     * @return {Object} velocity `x` and `y`\n     */\n    function getVelocity(deltaTime, x, y) {\n        return {\n            x: x / deltaTime || 0,\n            y: y / deltaTime || 0\n        };\n    }\n\n    /**\n     * get the direction between two points\n     * @param {Number} x\n     * @param {Number} y\n     * @return {Number} direction\n     */\n    function getDirection(x, y) {\n        if (x === y) {\n            return DIRECTION_NONE;\n        }\n\n        if (abs(x) >= abs(y)) {\n            return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        }\n        return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\n    }\n\n    /**\n     * calculate the absolute distance between two points\n     * @param {Object} p1 {x, y}\n     * @param {Object} p2 {x, y}\n     * @param {Array} [props] containing x and y keys\n     * @return {Number} distance\n     */\n    function getDistance(p1, p2, props) {\n        if (!props) {\n            props = PROPS_XY;\n        }\n        var x = p2[props[0]] - p1[props[0]],\n            y = p2[props[1]] - p1[props[1]];\n\n        return Math.sqrt((x * x) + (y * y));\n    }\n\n    /**\n     * calculate the angle between two coordinates\n     * @param {Object} p1\n     * @param {Object} p2\n     * @param {Array} [props] containing x and y keys\n     * @return {Number} angle\n     */\n    function getAngle(p1, p2, props) {\n        if (!props) {\n            props = PROPS_XY;\n        }\n        var x = p2[props[0]] - p1[props[0]],\n            y = p2[props[1]] - p1[props[1]];\n        return Math.atan2(y, x) * 180 / Math.PI;\n    }\n\n    /**\n     * calculate the rotation degrees between two pointersets\n     * @param {Array} start array of pointers\n     * @param {Array} end array of pointers\n     * @return {Number} rotation\n     */\n    function getRotation(start, end) {\n        return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\n    }\n\n    /**\n     * calculate the scale factor between two pointersets\n     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n     * @param {Array} start array of pointers\n     * @param {Array} end array of pointers\n     * @return {Number} scale\n     */\n    function getScale(start, end) {\n        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n    }\n\n    var MOUSE_INPUT_MAP = {\n        mousedown: INPUT_START,\n        mousemove: INPUT_MOVE,\n        mouseup: INPUT_END\n    };\n\n    var MOUSE_ELEMENT_EVENTS = 'mousedown';\n    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n    /**\n     * Mouse events input\n     * @constructor\n     * @extends Input\n     */\n    function MouseInput() {\n        this.evEl = MOUSE_ELEMENT_EVENTS;\n        this.evWin = MOUSE_WINDOW_EVENTS;\n\n        this.allow = true; // used by Input.TouchMouse to disable mouse events\n        this.pressed = false; // mousedown state\n\n        Input.apply(this, arguments);\n    }\n\n    inherit(MouseInput, Input, {\n        /**\n         * handle mouse events\n         * @param {Object} ev\n         */\n        handler: function MEhandler(ev) {\n            var eventType = MOUSE_INPUT_MAP[ev.type];\n\n            // on start we want to have the left mouse button down\n            if (eventType & INPUT_START && ev.button === 0) {\n                this.pressed = true;\n            }\n\n            if (eventType & INPUT_MOVE && ev.which !== 1) {\n                eventType = INPUT_END;\n            }\n\n            // mouse must be down, and mouse events are allowed (see the TouchMouse input)\n            if (!this.pressed || !this.allow) {\n                return;\n            }\n\n            if (eventType & INPUT_END) {\n                this.pressed = false;\n            }\n\n            this.callback(this.manager, eventType, {\n                pointers: [ev],\n                changedPointers: [ev],\n                pointerType: INPUT_TYPE_MOUSE,\n                srcEvent: ev\n            });\n        }\n    });\n\n    var POINTER_INPUT_MAP = {\n        pointerdown: INPUT_START,\n        pointermove: INPUT_MOVE,\n        pointerup: INPUT_END,\n        pointercancel: INPUT_CANCEL,\n        pointerout: INPUT_CANCEL\n    };\n\n    // in IE10 the pointer types is defined as an enum\n    var IE10_POINTER_TYPE_ENUM = {\n        2: INPUT_TYPE_TOUCH,\n        3: INPUT_TYPE_PEN,\n        4: INPUT_TYPE_MOUSE,\n        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n    };\n\n    var POINTER_ELEMENT_EVENTS = 'pointerdown';\n    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n    // IE10 has prefixed support, and case-sensitive\n    if (window.MSPointerEvent) {\n        POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n    }\n\n    /**\n     * Pointer events input\n     * @constructor\n     * @extends Input\n     */\n    function PointerEventInput() {\n        this.evEl = POINTER_ELEMENT_EVENTS;\n        this.evWin = POINTER_WINDOW_EVENTS;\n\n        Input.apply(this, arguments);\n\n        this.store = (this.manager.session.pointerEvents = []);\n    }\n\n    inherit(PointerEventInput, Input, {\n        /**\n         * handle mouse events\n         * @param {Object} ev\n         */\n        handler: function PEhandler(ev) {\n            var store = this.store;\n            var removePointer = false;\n\n            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n            var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n            // get index of the event in the store\n            var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n            // start and mouse must be down\n            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n                if (storeIndex < 0) {\n                    store.push(ev);\n                    storeIndex = store.length - 1;\n                }\n            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n                removePointer = true;\n            }\n\n            // it not found, so the pointer hasn't been down (so it's probably a hover)\n            if (storeIndex < 0) {\n                return;\n            }\n\n            // update the event in the store\n            store[storeIndex] = ev;\n\n            this.callback(this.manager, eventType, {\n                pointers: store,\n                changedPointers: [ev],\n                pointerType: pointerType,\n                srcEvent: ev\n            });\n\n            if (removePointer) {\n                // remove from the store\n                store.splice(storeIndex, 1);\n            }\n        }\n    });\n\n    var SINGLE_TOUCH_INPUT_MAP = {\n        touchstart: INPUT_START,\n        touchmove: INPUT_MOVE,\n        touchend: INPUT_END,\n        touchcancel: INPUT_CANCEL\n    };\n\n    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n    /**\n     * Touch events input\n     * @constructor\n     * @extends Input\n     */\n    function SingleTouchInput() {\n        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n        this.started = false;\n\n        Input.apply(this, arguments);\n    }\n\n    inherit(SingleTouchInput, Input, {\n        handler: function TEhandler(ev) {\n            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n            // should we handle the touch events?\n            if (type === INPUT_START) {\n                this.started = true;\n            }\n\n            if (!this.started) {\n                return;\n            }\n\n            var touches = normalizeSingleTouches.call(this, ev, type);\n\n            // when done, reset the started state\n            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n                this.started = false;\n            }\n\n            this.callback(this.manager, type, {\n                pointers: touches[0],\n                changedPointers: touches[1],\n                pointerType: INPUT_TYPE_TOUCH,\n                srcEvent: ev\n            });\n        }\n    });\n\n    /**\n     * @this {TouchInput}\n     * @param {Object} ev\n     * @param {Number} type flag\n     * @returns {undefined|Array} [all, changed]\n     */\n    function normalizeSingleTouches(ev, type) {\n        var all = toArray(ev.touches);\n        var changed = toArray(ev.changedTouches);\n\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            all = uniqueArray(all.concat(changed), 'identifier', true);\n        }\n\n        return [all, changed];\n    }\n\n    var TOUCH_INPUT_MAP = {\n        touchstart: INPUT_START,\n        touchmove: INPUT_MOVE,\n        touchend: INPUT_END,\n        touchcancel: INPUT_CANCEL\n    };\n\n    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n    /**\n     * Multi-user touch events input\n     * @constructor\n     * @extends Input\n     */\n    function TouchInput() {\n        this.evTarget = TOUCH_TARGET_EVENTS;\n        this.targetIds = {};\n\n        Input.apply(this, arguments);\n    }\n\n    inherit(TouchInput, Input, {\n        handler: function MTEhandler(ev) {\n            var type = TOUCH_INPUT_MAP[ev.type];\n            var touches = getTouches.call(this, ev, type);\n            if (!touches) {\n                return;\n            }\n\n            this.callback(this.manager, type, {\n                pointers: touches[0],\n                changedPointers: touches[1],\n                pointerType: INPUT_TYPE_TOUCH,\n                srcEvent: ev\n            });\n        }\n    });\n\n    /**\n     * @this {TouchInput}\n     * @param {Object} ev\n     * @param {Number} type flag\n     * @returns {undefined|Array} [all, changed]\n     */\n    function getTouches(ev, type) {\n        var allTouches = toArray(ev.touches);\n        var targetIds = this.targetIds;\n\n        // when there is only one touch, the process can be simplified\n        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n            targetIds[allTouches[0].identifier] = true;\n            return [allTouches, allTouches];\n        }\n\n        var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n            changedTargetTouches = [],\n            target = this.target;\n\n        // get target touches from touches\n        targetTouches = allTouches.filter(function(touch) {\n            return hasParent(touch.target, target);\n        });\n\n        // collect touches\n        if (type === INPUT_START) {\n            i = 0;\n            while (i < targetTouches.length) {\n                targetIds[targetTouches[i].identifier] = true;\n                i++;\n            }\n        }\n\n        // filter changed touches to only contain touches that exist in the collected target ids\n        i = 0;\n        while (i < changedTouches.length) {\n            if (targetIds[changedTouches[i].identifier]) {\n                changedTargetTouches.push(changedTouches[i]);\n            }\n\n            // cleanup removed touches\n            if (type & (INPUT_END | INPUT_CANCEL)) {\n                delete targetIds[changedTouches[i].identifier];\n            }\n            i++;\n        }\n\n        if (!changedTargetTouches.length) {\n            return;\n        }\n\n        return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches];\n    }\n\n    /**\n     * Combined touch and mouse input\n     *\n     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n     * This because touch devices also emit mouse events while doing a touch.\n     *\n     * @constructor\n     * @extends Input\n     */\n    function TouchMouseInput() {\n        Input.apply(this, arguments);\n\n        var handler = bindFn(this.handler, this);\n        this.touch = new TouchInput(this.manager, handler);\n        this.mouse = new MouseInput(this.manager, handler);\n    }\n\n    inherit(TouchMouseInput, Input, {\n        /**\n         * handle mouse and touch events\n         * @param {Hammer} manager\n         * @param {String} inputEvent\n         * @param {Object} inputData\n         */\n        handler: function TMEhandler(manager, inputEvent, inputData) {\n            var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n                isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n            // when we're in a touch event, so  block all upcoming mouse events\n            // most mobile browser also emit mouseevents, right after touchstart\n            if (isTouch) {\n                this.mouse.allow = false;\n            } else if (isMouse && !this.mouse.allow) {\n                return;\n            }\n\n            // reset the allowMouse when we're done\n            if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\n                this.mouse.allow = true;\n            }\n\n            this.callback(manager, inputEvent, inputData);\n        },\n\n        /**\n         * remove the event listeners\n         */\n        destroy: function destroy() {\n            this.touch.destroy();\n            this.mouse.destroy();\n        }\n    });\n\n    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n    // magical touchAction value\n    var TOUCH_ACTION_COMPUTE = 'compute';\n    var TOUCH_ACTION_AUTO = 'auto';\n    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n    var TOUCH_ACTION_NONE = 'none';\n    var TOUCH_ACTION_PAN_X = 'pan-x';\n    var TOUCH_ACTION_PAN_Y = 'pan-y';\n\n    /**\n     * Touch Action\n     * sets the touchAction property or uses the js alternative\n     * @param {Manager} manager\n     * @param {String} value\n     * @constructor\n     */\n    function TouchAction(manager, value) {\n        this.manager = manager;\n        this.set(value);\n    }\n\n    TouchAction.prototype = {\n        /**\n         * set the touchAction value on the element or enable the polyfill\n         * @param {String} value\n         */\n        set: function(value) {\n            // find out the touch-action by the event handlers\n            if (value == TOUCH_ACTION_COMPUTE) {\n                value = this.compute();\n            }\n\n            if (NATIVE_TOUCH_ACTION) {\n                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n            }\n            this.actions = value.toLowerCase().trim();\n        },\n\n        /**\n         * just re-set the touchAction value\n         */\n        update: function() {\n            this.set(this.manager.options.touchAction);\n        },\n\n        /**\n         * compute the value for the touchAction property based on the recognizer's settings\n         * @returns {String} value\n         */\n        compute: function() {\n            var actions = [];\n            each(this.manager.recognizers, function(recognizer) {\n                if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                    actions = actions.concat(recognizer.getTouchAction());\n                }\n            });\n            return cleanTouchActions(actions.join(' '));\n        },\n\n        /**\n         * this method is called on each input cycle and provides the preventing of the browser behavior\n         * @param {Object} input\n         */\n        preventDefaults: function(input) {\n            // not needed with native support for the touchAction property\n            if (NATIVE_TOUCH_ACTION) {\n                return;\n            }\n\n            var srcEvent = input.srcEvent;\n            var direction = input.offsetDirection;\n\n            // if the touch action did prevented once this session\n            if (this.manager.session.prevented) {\n                srcEvent.preventDefault();\n                return;\n            }\n\n            var actions = this.actions;\n            var hasNone = inStr(actions, TOUCH_ACTION_NONE);\n            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n\n            if (hasNone || (hasPanY && direction & DIRECTION_HORIZONTAL) || (hasPanX && direction & DIRECTION_VERTICAL)) {\n                return this.preventSrc(srcEvent);\n            }\n        },\n\n        /**\n         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n         * @param {Object} srcEvent\n         */\n        preventSrc: function(srcEvent) {\n            this.manager.session.prevented = true;\n            srcEvent.preventDefault();\n        }\n    };\n\n    /**\n     * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n     * @param {String} actions\n     * @returns {*}\n     */\n    function cleanTouchActions(actions) {\n        // none\n        if (inStr(actions, TOUCH_ACTION_NONE)) {\n            return TOUCH_ACTION_NONE;\n        }\n\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n        // pan-x and pan-y can be combined\n        if (hasPanX && hasPanY) {\n            return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;\n        }\n\n        // pan-x OR pan-y\n        if (hasPanX || hasPanY) {\n            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n        }\n\n        // manipulation\n        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n            return TOUCH_ACTION_MANIPULATION;\n        }\n\n        return TOUCH_ACTION_AUTO;\n    }\n\n    /**\n     * Recognizer flow explained; *\n     * All recognizers have the initial state of POSSIBLE when a input session starts.\n     * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n     * Example session for mouse-input: mousedown -> mousemove -> mouseup\n     *\n     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n     * which determines with state it should be.\n     *\n     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n     * POSSIBLE to give it another change on the next cycle.\n     *\n     *               Possible\n     *                  |\n     *            +-----+---------------+\n     *            |                     |\n     *      +-----+-----+               |\n     *      |           |               |\n     *   Failed      Cancelled          |\n     *                          +-------+------+\n     *                          |              |\n     *                      Recognized       Began\n     *                                         |\n     *                                      Changed\n     *                                         |\n     *                                  Ended/Recognized\n     */\n    var STATE_POSSIBLE = 1;\n    var STATE_BEGAN = 2;\n    var STATE_CHANGED = 4;\n    var STATE_ENDED = 8;\n    var STATE_RECOGNIZED = STATE_ENDED;\n    var STATE_CANCELLED = 16;\n    var STATE_FAILED = 32;\n\n    /**\n     * Recognizer\n     * Every recognizer needs to extend from this class.\n     * @constructor\n     * @param {Object} options\n     */\n    function Recognizer(options) {\n        this.id = uniqueId();\n\n        this.manager = null;\n        this.options = merge(options || {}, this.defaults);\n\n        // default is enable true\n        this.options.enable = ifUndefined(this.options.enable, true);\n\n        this.state = STATE_POSSIBLE;\n\n        this.simultaneous = {};\n        this.requireFail = [];\n    }\n\n    Recognizer.prototype = {\n        /**\n         * @virtual\n         * @type {Object}\n         */\n        defaults: {},\n\n        /**\n         * set options\n         * @param {Object} options\n         * @return {Recognizer}\n         */\n        set: function(options) {\n            extend(this.options, options);\n\n            // also update the touchAction, in case something changed about the directions/enabled state\n            this.manager && this.manager.touchAction.update();\n            return this;\n        },\n\n        /**\n         * recognize simultaneous with an other recognizer.\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        recognizeWith: function(otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n                return this;\n            }\n\n            var simultaneous = this.simultaneous;\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            if (!simultaneous[otherRecognizer.id]) {\n                simultaneous[otherRecognizer.id] = otherRecognizer;\n                otherRecognizer.recognizeWith(this);\n            }\n            return this;\n        },\n\n        /**\n         * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        dropRecognizeWith: function(otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n                return this;\n            }\n\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            delete this.simultaneous[otherRecognizer.id];\n            return this;\n        },\n\n        /**\n         * recognizer can only run when an other is failing\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        requireFailure: function(otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n                return this;\n            }\n\n            var requireFail = this.requireFail;\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            if (inArray(requireFail, otherRecognizer) === -1) {\n                requireFail.push(otherRecognizer);\n                otherRecognizer.requireFailure(this);\n            }\n            return this;\n        },\n\n        /**\n         * drop the requireFailure link. it does not remove the link on the other recognizer.\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        dropRequireFailure: function(otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n                return this;\n            }\n\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            var index = inArray(this.requireFail, otherRecognizer);\n            if (index > -1) {\n                this.requireFail.splice(index, 1);\n            }\n            return this;\n        },\n\n        /**\n         * has require failures boolean\n         * @returns {boolean}\n         */\n        hasRequireFailures: function() {\n            return this.requireFail.length > 0;\n        },\n\n        /**\n         * if the recognizer can recognize simultaneous with an other recognizer\n         * @param {Recognizer} otherRecognizer\n         * @returns {Boolean}\n         */\n        canRecognizeWith: function(otherRecognizer) {\n            return !!this.simultaneous[otherRecognizer.id];\n        },\n\n        /**\n         * You should use `tryEmit` instead of `emit` directly to check\n         * that all the needed recognizers has failed before emitting.\n         * @param {Object} input\n         */\n        emit: function(input) {\n            var self = this;\n            var state = this.state;\n\n            function emit(withState) {\n                self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);\n            }\n\n            // 'panstart' and 'panmove'\n            if (state < STATE_ENDED) {\n                emit(true);\n            }\n\n            emit(); // simple 'eventName' events\n\n            // panend and pancancel\n            if (state >= STATE_ENDED) {\n                emit(true);\n            }\n        },\n\n        /**\n         * Check that all the require failure recognizers has failed,\n         * if true, it emits a gesture event,\n         * otherwise, setup the state to FAILED.\n         * @param {Object} input\n         */\n        tryEmit: function(input) {\n            if (this.canEmit()) {\n                return this.emit(input);\n            }\n            // it's failing anyway\n            this.state = STATE_FAILED;\n        },\n\n        /**\n         * can we emit?\n         * @returns {boolean}\n         */\n        canEmit: function() {\n            var i = 0;\n            while (i < this.requireFail.length) {\n                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                    return false;\n                }\n                i++;\n            }\n            return true;\n        },\n\n        /**\n         * update the recognizer\n         * @param {Object} inputData\n         */\n        recognize: function(inputData) {\n            // make a new copy of the inputData\n            // so we can change the inputData without messing up the other recognizers\n            var inputDataClone = extend({}, inputData);\n\n            // is is enabled and allow recognizing?\n            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n                this.reset();\n                this.state = STATE_FAILED;\n                return;\n            }\n\n            // reset when we've reached the end\n            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n                this.state = STATE_POSSIBLE;\n            }\n\n            this.state = this.process(inputDataClone);\n\n            // the recognizer has recognized a gesture\n            // so trigger an event\n            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n                this.tryEmit(inputDataClone);\n            }\n        },\n\n        /**\n         * return the state of the recognizer\n         * the actual recognizing happens in this method\n         * @virtual\n         * @param {Object} inputData\n         * @returns {Const} STATE\n         */\n        process: function(inputData) {}, // jshint ignore:line\n\n        /**\n         * return the preferred touch-action\n         * @virtual\n         * @returns {Array}\n         */\n        getTouchAction: function() {},\n\n        /**\n         * called when the gesture isn't allowed to recognize\n         * like when another is being recognized or it is disabled\n         * @virtual\n         */\n        reset: function() {}\n    };\n\n    /**\n     * get a usable string, used as event postfix\n     * @param {Const} state\n     * @returns {String} state\n     */\n    function stateStr(state) {\n        if (state & STATE_CANCELLED) {\n            return 'cancel';\n        } else if (state & STATE_ENDED) {\n            return 'end';\n        } else if (state & STATE_CHANGED) {\n            return 'move';\n        } else if (state & STATE_BEGAN) {\n            return 'start';\n        }\n        return '';\n    }\n\n    /**\n     * direction cons to string\n     * @param {Const} direction\n     * @returns {String}\n     */\n    function directionStr(direction) {\n        if (direction == DIRECTION_DOWN) {\n            return 'down';\n        } else if (direction == DIRECTION_UP) {\n            return 'up';\n        } else if (direction == DIRECTION_LEFT) {\n            return 'left';\n        } else if (direction == DIRECTION_RIGHT) {\n            return 'right';\n        }\n        return '';\n    }\n\n    /**\n     * get a recognizer by name if it is bound to a manager\n     * @param {Recognizer|String} otherRecognizer\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer}\n     */\n    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n        var manager = recognizer.manager;\n        if (manager) {\n            return manager.get(otherRecognizer);\n        }\n        return otherRecognizer;\n    }\n\n    /**\n     * This recognizer is just used as a base for the simple attribute recognizers.\n     * @constructor\n     * @extends Recognizer\n     */\n    function AttrRecognizer() {\n        Recognizer.apply(this, arguments);\n    }\n\n    inherit(AttrRecognizer, Recognizer, {\n        /**\n         * @namespace\n         * @memberof AttrRecognizer\n         */\n        defaults: {\n            /**\n             * @type {Number}\n             * @default 1\n             */\n            pointers: 1\n        },\n\n        /**\n         * Used to check if it the recognizer receives valid input, like input.distance > 10.\n         * @memberof AttrRecognizer\n         * @param {Object} input\n         * @returns {Boolean} recognized\n         */\n        attrTest: function(input) {\n            var optionPointers = this.options.pointers;\n            return optionPointers === 0 || input.pointers.length === optionPointers;\n        },\n\n        /**\n         * Process the input and return the state for the recognizer\n         * @memberof AttrRecognizer\n         * @param {Object} input\n         * @returns {*} State\n         */\n        process: function(input) {\n            var state = this.state;\n            var eventType = input.eventType;\n\n            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n            var isValid = this.attrTest(input);\n\n            // on cancel input and we've recognized before, return STATE_CANCELLED\n            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n                return state | STATE_CANCELLED;\n            } else if (isRecognized || isValid) {\n                if (eventType & INPUT_END) {\n                    return state | STATE_ENDED;\n                } else if (!(state & STATE_BEGAN)) {\n                    return STATE_BEGAN;\n                }\n                return state | STATE_CHANGED;\n            }\n            return STATE_FAILED;\n        }\n    });\n\n    /**\n     * Pan\n     * Recognized when the pointer is down and moved in the allowed direction.\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function PanRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n\n        this.pX = null;\n        this.pY = null;\n    }\n\n    inherit(PanRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof PanRecognizer\n         */\n        defaults: {\n            event: 'pan',\n            threshold: 10,\n            pointers: 1,\n            direction: DIRECTION_ALL\n        },\n\n        getTouchAction: function() {\n            var direction = this.options.direction;\n            var actions = [];\n            if (direction & DIRECTION_HORIZONTAL) {\n                actions.push(TOUCH_ACTION_PAN_Y);\n            }\n            if (direction & DIRECTION_VERTICAL) {\n                actions.push(TOUCH_ACTION_PAN_X);\n            }\n            return actions;\n        },\n\n        directionTest: function(input) {\n            var options = this.options;\n            var hasMoved = true;\n            var distance = input.distance;\n            var direction = input.direction;\n            var x = input.deltaX;\n            var y = input.deltaY;\n\n            // lock to axis?\n            if (!(direction & options.direction)) {\n                if (options.direction & DIRECTION_HORIZONTAL) {\n                    direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                    hasMoved = x != this.pX;\n                    distance = Math.abs(input.deltaX);\n                } else {\n                    direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                    hasMoved = y != this.pY;\n                    distance = Math.abs(input.deltaY);\n                }\n            }\n            input.direction = direction;\n            return hasMoved && distance > options.threshold && direction & options.direction;\n        },\n\n        attrTest: function(input) {\n            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n        },\n\n        emit: function(input) {\n            this.pX = input.deltaX;\n            this.pY = input.deltaY;\n\n            var direction = directionStr(input.direction);\n            if (direction) {\n                this.manager.emit(this.options.event + direction, input);\n            }\n\n            this._super.emit.call(this, input);\n        }\n    });\n\n    /**\n     * Pinch\n     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function PinchRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n    }\n\n    inherit(PinchRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof PinchRecognizer\n         */\n        defaults: {\n            event: 'pinch',\n            threshold: 0,\n            pointers: 2\n        },\n\n        getTouchAction: function() {\n            return [TOUCH_ACTION_NONE];\n        },\n\n        attrTest: function(input) {\n            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n        },\n\n        emit: function(input) {\n            this._super.emit.call(this, input);\n            if (input.scale !== 1) {\n                var inOut = input.scale < 1 ? 'in' : 'out';\n                this.manager.emit(this.options.event + inOut, input);\n            }\n        }\n    });\n\n    /**\n     * Press\n     * Recognized when the pointer is down for x ms without any movement.\n     * @constructor\n     * @extends Recognizer\n     */\n    function PressRecognizer() {\n        Recognizer.apply(this, arguments);\n\n        this._timer = null;\n        this._input = null;\n    }\n\n    inherit(PressRecognizer, Recognizer, {\n        /**\n         * @namespace\n         * @memberof PressRecognizer\n         */\n        defaults: {\n            event: 'press',\n            pointers: 1,\n            time: 500, // minimal time of the pointer to be pressed\n            threshold: 5 // a minimal movement is ok, but keep it low\n        },\n\n        getTouchAction: function() {\n            return [TOUCH_ACTION_AUTO];\n        },\n\n        process: function(input) {\n            var options = this.options;\n            var validPointers = input.pointers.length === options.pointers;\n            var validMovement = input.distance < options.threshold;\n            var validTime = input.deltaTime > options.time;\n\n            this._input = input;\n\n            // we only allow little movement\n            // and we've reached an end event, so a tap is possible\n            if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n                this.reset();\n            } else if (input.eventType & INPUT_START) {\n                this.reset();\n                this._timer = setTimeoutContext(function() {\n                    this.state = STATE_RECOGNIZED;\n                    this.tryEmit();\n                }, options.time, this);\n            } else if (input.eventType & INPUT_END) {\n                return STATE_RECOGNIZED;\n            }\n            return STATE_FAILED;\n        },\n\n        reset: function() {\n            clearTimeout(this._timer);\n        },\n\n        emit: function(input) {\n            if (this.state !== STATE_RECOGNIZED) {\n                return;\n            }\n\n            if (input && (input.eventType & INPUT_END)) {\n                this.manager.emit(this.options.event + 'up', input);\n            } else {\n                this._input.timeStamp = now();\n                this.manager.emit(this.options.event, this._input);\n            }\n        }\n    });\n\n    /**\n     * Rotate\n     * Recognized when two or more pointer are moving in a circular motion.\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function RotateRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n    }\n\n    inherit(RotateRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof RotateRecognizer\n         */\n        defaults: {\n            event: 'rotate',\n            threshold: 0,\n            pointers: 2\n        },\n\n        getTouchAction: function() {\n            return [TOUCH_ACTION_NONE];\n        },\n\n        attrTest: function(input) {\n            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n        }\n    });\n\n    /**\n     * Swipe\n     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function SwipeRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n    }\n\n    inherit(SwipeRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof SwipeRecognizer\n         */\n        defaults: {\n            event: 'swipe',\n            threshold: 10,\n            velocity: 0.65,\n            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n            pointers: 1\n        },\n\n        getTouchAction: function() {\n            return PanRecognizer.prototype.getTouchAction.call(this);\n        },\n\n        attrTest: function(input) {\n            var direction = this.options.direction;\n            var velocity;\n\n            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n                velocity = input.velocity;\n            } else if (direction & DIRECTION_HORIZONTAL) {\n                velocity = input.velocityX;\n            } else if (direction & DIRECTION_VERTICAL) {\n                velocity = input.velocityY;\n            }\n\n            return this._super.attrTest.call(this, input) && direction & input.direction && input.distance > this.options.threshold && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n        },\n\n        emit: function(input) {\n            var direction = directionStr(input.direction);\n            if (direction) {\n                this.manager.emit(this.options.event + direction, input);\n            }\n\n            this.manager.emit(this.options.event, input);\n        }\n    });\n\n    /**\n     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n     * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n     * a single tap.\n     *\n     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n     * multi-taps being recognized.\n     * @constructor\n     * @extends Recognizer\n     */\n    function TapRecognizer() {\n        Recognizer.apply(this, arguments);\n\n        // previous time and center,\n        // used for tap counting\n        this.pTime = false;\n        this.pCenter = false;\n\n        this._timer = null;\n        this._input = null;\n        this.count = 0;\n    }\n\n    inherit(TapRecognizer, Recognizer, {\n        /**\n         * @namespace\n         * @memberof PinchRecognizer\n         */\n        defaults: {\n            event: 'tap',\n            pointers: 1,\n            taps: 1,\n            interval: 300, // max time between the multi-tap taps\n            time: 250, // max time of the pointer to be down (like finger on the screen)\n            threshold: 2, // a minimal movement is ok, but keep it low\n            posThreshold: 10 // a multi-tap can be a bit off the initial position\n        },\n\n        getTouchAction: function() {\n            return [TOUCH_ACTION_MANIPULATION];\n        },\n\n        process: function(input) {\n            var options = this.options;\n\n            var validPointers = input.pointers.length === options.pointers;\n            var validMovement = input.distance < options.threshold;\n            var validTouchTime = input.deltaTime < options.time;\n\n            this.reset();\n\n            if ((input.eventType & INPUT_START) && (this.count === 0)) {\n                return this.failTimeout();\n            }\n\n            // we only allow little movement\n            // and we've reached an end event, so a tap is possible\n            if (validMovement && validTouchTime && validPointers) {\n                if (input.eventType != INPUT_END) {\n                    return this.failTimeout();\n                }\n\n                var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n                this.pTime = input.timeStamp;\n                this.pCenter = input.center;\n\n                if (!validMultiTap || !validInterval) {\n                    this.count = 1;\n                } else {\n                    this.count += 1;\n                }\n\n                this._input = input;\n\n                // if tap count matches we have recognized it,\n                // else it has began recognizing...\n                var tapCount = this.count % options.taps;\n                if (tapCount === 0) {\n                    // no failing requirements, immediately trigger the tap event\n                    // or wait as long as the multitap interval to trigger\n                    if (!this.hasRequireFailures()) {\n                        return STATE_RECOGNIZED;\n                    } else {\n                        this._timer = setTimeoutContext(function() {\n                            this.state = STATE_RECOGNIZED;\n                            this.tryEmit();\n                        }, options.interval, this);\n                        return STATE_BEGAN;\n                    }\n                }\n            }\n            return STATE_FAILED;\n        },\n\n        failTimeout: function() {\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_FAILED;\n            }, this.options.interval, this);\n            return STATE_FAILED;\n        },\n\n        reset: function() {\n            clearTimeout(this._timer);\n        },\n\n        emit: function() {\n            if (this.state == STATE_RECOGNIZED) {\n                this._input.tapCount = this.count;\n                this.manager.emit(this.options.event, this._input);\n            }\n        }\n    });\n\n    /**\n     * Simple way to create an manager with a default set of recognizers.\n     * @param {HTMLElement} element\n     * @param {Object} [options]\n     * @constructor\n     */\n    function Hammer(element, options) {\n        options = options || {};\n        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n        return new Manager(element, options);\n    }\n\n    /**\n     * @const {string}\n     */\n    Hammer.VERSION = '2.0.4';\n\n    /**\n     * default settings\n     * @namespace\n     */\n    Hammer.defaults = {\n        /**\n         * set if DOM events are being triggered.\n         * But this is slower and unused by simple implementations, so disabled by default.\n         * @type {Boolean}\n         * @default false\n         */\n        domEvents: false,\n\n        /**\n         * The value for the touchAction property/fallback.\n         * When set to `compute` it will magically set the correct value based on the added recognizers.\n         * @type {String}\n         * @default compute\n         */\n        touchAction: TOUCH_ACTION_COMPUTE,\n\n        /**\n         * @type {Boolean}\n         * @default true\n         */\n        enable: true,\n\n        /**\n         * EXPERIMENTAL FEATURE -- can be removed/changed\n         * Change the parent input target element.\n         * If Null, then it is being set the to main element.\n         * @type {Null|EventTarget}\n         * @default null\n         */\n        inputTarget: null,\n\n        /**\n         * force an input class\n         * @type {Null|Function}\n         * @default null\n         */\n        inputClass: null,\n\n        /**\n         * Default recognizer setup when calling `Hammer()`\n         * When creating a new Manager these will be skipped.\n         * @type {Array}\n         */\n        preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {\n            enable: false\n        }],\n            [PinchRecognizer, {\n                enable: false\n            }, ['rotate']],\n            [SwipeRecognizer, {\n                direction: DIRECTION_HORIZONTAL\n            }],\n            [PanRecognizer, {\n                direction: DIRECTION_HORIZONTAL\n            }, ['swipe']],\n            [TapRecognizer],\n            [TapRecognizer, {\n                event: 'doubletap',\n                taps: 2\n            }, ['tap']],\n            [PressRecognizer]\n        ],\n\n        /**\n         * Some CSS properties can be used to improve the working of Hammer.\n         * Add them to this method and they will be set when creating a new Manager.\n         * @namespace\n         */\n        cssProps: {\n            /**\n             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n             * @type {String}\n             * @default 'none'\n             */\n            userSelect: 'none',\n\n            /**\n             * Disable the Windows Phone grippers when pressing an element.\n             * @type {String}\n             * @default 'none'\n             */\n            touchSelect: 'none',\n\n            /**\n             * Disables the default callout shown when you touch and hold a touch target.\n             * On iOS, when you touch and hold a touch target such as a link, Safari displays\n             * a callout containing information about the link. This property allows you to disable that callout.\n             * @type {String}\n             * @default 'none'\n             */\n            touchCallout: 'none',\n\n            /**\n             * Specifies whether zooming is enabled. Used by IE10>\n             * @type {String}\n             * @default 'none'\n             */\n            contentZooming: 'none',\n\n            /**\n             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n             * @type {String}\n             * @default 'none'\n             */\n            userDrag: 'none',\n\n            /**\n             * Overrides the highlight color shown when the user taps a link or a JavaScript\n             * clickable element in iOS. This property obeys the alpha value, if specified.\n             * @type {String}\n             * @default 'rgba(0,0,0,0)'\n             */\n            tapHighlightColor: 'rgba(0,0,0,0)'\n        }\n    };\n\n    var STOP = 1;\n    var FORCED_STOP = 2;\n\n    /**\n     * Manager\n     * @param {HTMLElement} element\n     * @param {Object} [options]\n     * @constructor\n     */\n    function Manager(element, options) {\n        options = options || {};\n\n        this.options = merge(options, Hammer.defaults);\n        this.options.inputTarget = this.options.inputTarget || element;\n\n        this.handlers = {};\n        this.session = {};\n        this.recognizers = [];\n\n        this.element = element;\n        this.input = createInputInstance(this);\n        this.touchAction = new TouchAction(this, this.options.touchAction);\n\n        toggleCssProps(this, true);\n\n        each(options.recognizers, function(item) {\n            var recognizer = this.add(new(item[0])(item[1]));\n            item[2] && recognizer.recognizeWith(item[2]);\n            item[3] && recognizer.requireFailure(item[3]);\n        }, this);\n    }\n\n    Manager.prototype = {\n        /**\n         * set options\n         * @param {Object} options\n         * @returns {Manager}\n         */\n        set: function(options) {\n            extend(this.options, options);\n\n            // Options that need a little more setup\n            if (options.touchAction) {\n                this.touchAction.update();\n            }\n            if (options.inputTarget) {\n                // Clean up existing event listeners and reinitialize\n                this.input.destroy();\n                this.input.target = options.inputTarget;\n                this.input.init();\n            }\n            return this;\n        },\n\n        /**\n         * stop recognizing for this session.\n         * This session will be discarded, when a new [input]start event is fired.\n         * When forced, the recognizer cycle is stopped immediately.\n         * @param {Boolean} [force]\n         */\n        stop: function(force) {\n            this.session.stopped = force ? FORCED_STOP : STOP;\n        },\n\n        /**\n         * run the recognizers!\n         * called by the inputHandler function on every movement of the pointers (touches)\n         * it walks through all the recognizers and tries to detect the gesture that is being made\n         * @param {Object} inputData\n         */\n        recognize: function(inputData) {\n            var session = this.session;\n            if (session.stopped) {\n                return;\n            }\n\n            // run the touch-action polyfill\n            this.touchAction.preventDefaults(inputData);\n\n            var recognizer;\n            var recognizers = this.recognizers;\n\n            // this holds the recognizer that is being recognized.\n            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n            // if no recognizer is detecting a thing, it is set to `null`\n            var curRecognizer = session.curRecognizer;\n\n            // reset when the last recognizer is recognized\n            // or when we're in a new session\n            if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n                curRecognizer = session.curRecognizer = null;\n            }\n\n            var i = 0;\n            while (i < recognizers.length) {\n                recognizer = recognizers[i];\n\n                // find out if we are allowed try to recognize the input for this one.\n                // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n                //      that is being recognized.\n                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n                //      this can be setup with the `recognizeWith()` method on the recognizer.\n                if (session.stopped !== FORCED_STOP && ( // 1\n                !curRecognizer || recognizer == curRecognizer || // 2\n                recognizer.canRecognizeWith(curRecognizer))) { // 3\n                    recognizer.recognize(inputData);\n                } else {\n                    recognizer.reset();\n                }\n\n                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n                // current active recognizer. but only if we don't already have an active recognizer\n                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                    curRecognizer = session.curRecognizer = recognizer;\n                }\n                i++;\n            }\n        },\n\n        /**\n         * get a recognizer by its event name.\n         * @param {Recognizer|String} recognizer\n         * @returns {Recognizer|Null}\n         */\n        get: function(recognizer) {\n            if (recognizer instanceof Recognizer) {\n                return recognizer;\n            }\n\n            var recognizers = this.recognizers;\n            for (var i = 0; i < recognizers.length; i++) {\n                if (recognizers[i].options.event == recognizer) {\n                    return recognizers[i];\n                }\n            }\n            return null;\n        },\n\n        /**\n         * add a recognizer to the manager\n         * existing recognizers with the same event name will be removed\n         * @param {Recognizer} recognizer\n         * @returns {Recognizer|Manager}\n         */\n        add: function(recognizer) {\n            if (invokeArrayArg(recognizer, 'add', this)) {\n                return this;\n            }\n\n            // remove existing\n            var existing = this.get(recognizer.options.event);\n            if (existing) {\n                this.remove(existing);\n            }\n\n            this.recognizers.push(recognizer);\n            recognizer.manager = this;\n\n            this.touchAction.update();\n            return recognizer;\n        },\n\n        /**\n         * remove a recognizer by name or instance\n         * @param {Recognizer|String} recognizer\n         * @returns {Manager}\n         */\n        remove: function(recognizer) {\n            if (invokeArrayArg(recognizer, 'remove', this)) {\n                return this;\n            }\n\n            var recognizers = this.recognizers;\n            recognizer = this.get(recognizer);\n            recognizers.splice(inArray(recognizers, recognizer), 1);\n\n            this.touchAction.update();\n            return this;\n        },\n\n        /**\n         * bind event\n         * @param {String} events\n         * @param {Function} handler\n         * @returns {EventEmitter} this\n         */\n        on: function(events, handler) {\n            var handlers = this.handlers;\n            each(splitStr(events), function(event) {\n                handlers[event] = handlers[event] || [];\n                handlers[event].push(handler);\n            });\n            return this;\n        },\n\n        /**\n         * unbind event, leave emit blank to remove all handlers\n         * @param {String} events\n         * @param {Function} [handler]\n         * @returns {EventEmitter} this\n         */\n        off: function(events, handler) {\n            var handlers = this.handlers;\n            each(splitStr(events), function(event) {\n                if (!handler) {\n                    delete handlers[event];\n                } else {\n                    handlers[event].splice(inArray(handlers[event], handler), 1);\n                }\n            });\n            return this;\n        },\n\n        /**\n         * emit event to the listeners\n         * @param {String} event\n         * @param {Object} data\n         */\n        emit: function(event, data) {\n            // we also want to trigger dom events\n            if (this.options.domEvents) {\n                triggerDomEvent(event, data);\n            }\n\n            // no handlers, so skip it all\n            var handlers = this.handlers[event] && this.handlers[event].slice();\n            if (!handlers || !handlers.length) {\n                return;\n            }\n\n            data.type = event;\n            data.preventDefault = function() {\n                data.srcEvent.preventDefault();\n            };\n\n            var i = 0;\n            while (i < handlers.length) {\n                handlers[i](data);\n                i++;\n            }\n        },\n\n        /**\n         * destroy the manager and unbinds all events\n         * it doesn't unbind dom events, that is the user own responsibility\n         */\n        destroy: function() {\n            this.element && toggleCssProps(this, false);\n\n            this.handlers = {};\n            this.session = {};\n            this.input.destroy();\n            this.element = null;\n        }\n    };\n\n    /**\n     * add/remove the css properties as defined in manager.options.cssProps\n     * @param {Manager} manager\n     * @param {Boolean} add\n     */\n    function toggleCssProps(manager, add) {\n        var element = manager.element;\n        each(manager.options.cssProps, function(value, name) {\n            element.style[prefixed(element.style, name)] = add ? value : '';\n        });\n    }\n\n    /**\n     * trigger dom event\n     * @param {String} event\n     * @param {Object} data\n     */\n    function triggerDomEvent(event, data) {\n        var gestureEvent = document.createEvent('Event');\n        gestureEvent.initEvent(event, true, true);\n        gestureEvent.gesture = data;\n        data.target.dispatchEvent(gestureEvent);\n    }\n\n    extend(Hammer, {\n        INPUT_START: INPUT_START,\n        INPUT_MOVE: INPUT_MOVE,\n        INPUT_END: INPUT_END,\n        INPUT_CANCEL: INPUT_CANCEL,\n\n        STATE_POSSIBLE: STATE_POSSIBLE,\n        STATE_BEGAN: STATE_BEGAN,\n        STATE_CHANGED: STATE_CHANGED,\n        STATE_ENDED: STATE_ENDED,\n        STATE_RECOGNIZED: STATE_RECOGNIZED,\n        STATE_CANCELLED: STATE_CANCELLED,\n        STATE_FAILED: STATE_FAILED,\n\n        DIRECTION_NONE: DIRECTION_NONE,\n        DIRECTION_LEFT: DIRECTION_LEFT,\n        DIRECTION_RIGHT: DIRECTION_RIGHT,\n        DIRECTION_UP: DIRECTION_UP,\n        DIRECTION_DOWN: DIRECTION_DOWN,\n        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n        DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n        DIRECTION_ALL: DIRECTION_ALL,\n\n        Manager: Manager,\n        Input: Input,\n        TouchAction: TouchAction,\n\n        TouchInput: TouchInput,\n        MouseInput: MouseInput,\n        PointerEventInput: PointerEventInput,\n        TouchMouseInput: TouchMouseInput,\n        SingleTouchInput: SingleTouchInput,\n\n        Recognizer: Recognizer,\n        AttrRecognizer: AttrRecognizer,\n        Tap: TapRecognizer,\n        Pan: PanRecognizer,\n        Swipe: SwipeRecognizer,\n        Pinch: PinchRecognizer,\n        Rotate: RotateRecognizer,\n        Press: PressRecognizer,\n\n        on: addEventListeners,\n        off: removeEventListeners,\n        each: each,\n        merge: merge,\n        extend: extend,\n        inherit: inherit,\n        bindFn: bindFn,\n        prefixed: prefixed\n    });\n\n  \n\n\n// $.extend(Index.prototype, Common.prototype, init: function() {\n\n// });\n\nmodule.exports = Hammer;\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/qiyuan/.spon/mobi/fecomponent/mobi-hammer/0.0.1/index.js\n ** module id = 1\n ** module chunks = 0\n **/","'use strict';\n\nvar globalConfig = {};\n\nglobalConfig.Browser = {\n  versions: function () {\n    var u = navigator.userAgent, app = navigator.appVersion;\n    return {//移动终端浏览器版本信息\n      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核\n      mobile: !!u.match(/AppleWebKit.*Mobile.*/) || !!u.match(/AppleWebKit/), //是否为移动终端\n      ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端\n      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器\n      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者QQHD浏览器\n      iPad: u.indexOf('iPad') > -1, //是否iPad\n      webApp: u.indexOf('Safari') == -1, //是否web应该程序，没有头部与底部\n      weixin: u.toLowerCase().indexOf('micromessenger') > -1, //是否微信内置浏览器,\n      showjoyiOS: u.indexOf('ShowJoyiOS') > -1, // //是否iOS官方客户端内置浏览器\n      showjoyAndroid: u.indexOf('ShowJoyAndroid') > -1, //是否Android官方客户端内置浏览器\n      iOSAPP: u.indexOf('iOSAPP') > -1, // //是否iOS官方客户端内置浏览器\n      androidAPP: u.indexOf('androidAPP') > -1, //是否Android官方客户端内置浏览器\n      showjoyShopiOs: u.indexOf('showjoyshopiOS') > -1, \n      showjoyShopAndroid: u.indexOf('showjoyShopAndroid') > -1\n    };\n  } (),\n  language: (navigator.browserLanguage || navigator.language).toLowerCase()\n};\n\nglobalConfig.Env = (function () {\n  var hostname = window.location.hostname;\n  if ((hostname.indexOf('showjoy.net') !== -1) || (hostname.indexOf('ggl.net') !== -1)) {\n    return 'test';\n  } else if ((hostname.indexOf('showjoy.com') !== -1) || (hostname.indexOf('ggl.com') !== -1)) {\n    return 'alive';\n  }\n})();\n\nmodule.exports = globalConfig;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/qiyuan/.spon/mobi/fecomponent/mobi-detect-ua/0.0.4/index.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\nrequire(\"fecomponent/mobi-zepto-callbacks\");\nrequire(\"fecomponent/mobi-zepto-deferred\");\nrequire('./js-debug.less');\n\nvar globalConfig = require('fecomponent/mobi-detect-ua');\nvar isAndroid = globalConfig.Browser.versions.showjoyAndroid || globalConfig.Browser.versions.androidAPP || globalConfig.Browser.versions.showjoyShopAndroid;\nvar isiOS = globalConfig.Browser.versions.showjoyiOS || globalConfig.Browser.versions.iOSAPP || globalConfig.Browser.versions.showjoyShopiOs;\n\n/**\n * @info jsBridge,兼容oc和android\n */\nvar _jsBridge;\n\n// 保存native层调用的结果，用于js层的回调\nvar retFromNative, cbsAfterExecNativeMethod = [];\nvar messagingIframe;\nvar _createQueueReadyIframe = function(doc, schema) {\n    messagingIframe = doc.createElement('iframe');\n    messagingIframe.style.display = 'none';\n    messagingIframe.src = schema;\n    doc.documentElement.appendChild(messagingIframe);\n};\n\nvar JSBridge = {\n    _init: function() {\n        if (isiOS) {\n            var def = $.Deferred();\n\n            if (_jsBridge) {\n                setTimeout(function() {\n                    def.resolve(_jsBridge);\n                }, 0);\n                return def.promise();\n            } else {\n                document.addEventListener('WebViewJavascriptBridgeReady', function() {\n                    _jsBridge = window.WebViewJavascriptBridge;\n\n                    // 初始化jsBridge,此处不添加默认的回调函数\n                    // 拷贝receiveMessageQueue数组并置空\n                    _jsBridge.init();\n                    def.resolve(_jsBridge);\n                });\n                return def.promise();\n            }\n        } else if (isAndroid) {\n            // 安卓下无需指定特别的交互流程\n            // 通信依靠WebView组件,java通过loadUrl调用js函数,\n            // android4.4之前通过loadUrl执行js没有返回值,可通过js层调用java方法完成返回值的传递\n            // android4.4可通过evaluateJavascript函数执行js，并通过回调接受返回值\n        }\n    },\n\n    /**\n     * 注册具名方法,当native层调用具名方法时,执行该方法\n     * iOS通过UIWebView，Android通过WebView\n     *\n     * @param methodName 函数名\n     * @param method  method函数只接受一个对象,为native层传入的消息\n     */\n    registerHandler: function(methodName, method) {\n        var _this = this,\n            ret;\n\n        if (arguments.length !== 2) {\n            return;\n        }\n\n        if (_this._isDebug) {\n            //registerHandler methodName\n            _this._debugOutPut('registerHandler(regist) - methodName: ' + methodName, this._debugStyle._NORMAL_);\n        }\n\n        if (isiOS) {\n            _this._init()\n                .then(function(bridge) {\n                bridge.registerHandler(methodName, function(message, responseCallback) {\n\n                    if (_this._isDebug) {\n                        //registerHandler methodName\n                        _this._debugOutPut('registerHandler - responseData: ' + JSON.stringify(message), _this._debugStyle._NORMAL_);\n                    }\n\n                    ret = method(message);\n                    // 发送信息给oc层\n                    responseCallback(JSON.stringify(ret));\n                });\n            })\n        } else if (isAndroid) {\n            // 将注册的方法透出到window.javaObj的属性上\n            window.javaObj = window.javaObj ? window.javaObj : {};\n            window.javaObj[methodName] = function(message) {\n                if (_this._isDebug) {\n                    //registerHandler methodName\n                    _this._debugOutPut('registerHandler - responseData: ' + JSON.stringify(message), _this._debugStyle._NORMAL_);\n                }\n\n                //前端根据获取的参数进行方法的调用并返回内容\n                ret = method(JSON.stringify(message));\n\n                //针对安卓进行兼容处理，获取返回的数据\n                if (ret) {\n                    _this.callHandler('android_r_callback_data', ret, function() {});\n                }\n                // java执行js函数不返回结果，通过url传递序列化结果\n                // _createQueueReadyIframe(document, 'transfer://toAndroid/' + encodeURIComponent(JSON.stringify(ret)));\n            };\n        }\n    },\n    /**\n     * js层调用native层:iOS通过UIWebView，Android通过WebView\n     *\n     * @param methodName @type string\n     * @param params @type object\n     * @param callback @type function\n     */\n    callHandler: function(methodName, params, callback) {\n        if (arguments.length !== 3) {\n            return;\n        }\n        var _this = this,\n            message;\n\n        if (_this._isDebug) {\n            _this._debugOutPut('callHandler - methodName: ' + methodName, _this._debugStyle._NORMAL_);\n            _this._debugOutPut('callHandler - params: ' + JSON.stringify(params), _this._debugStyle._NORMAL_);\n        }\n\n        if (isiOS) {\n            _this._init()\n                .then(function(bridge) {\n                bridge.callHandler(methodName, params, function(message) {\n\n                    //调用app方法返回的数据\n                    if (_this._isDebug) {\n                        _this._debugOutPut('callHandeler reponse data: ' + JSON.stringify(message), _this._debugStyle._NORMAL_);\n                    }\n\n                    callback(message);\n                });\n            });\n        } else if (isAndroid) {\n            // java方法注入到WebView的js执行环境中\n            // 将注册的方法透出到window.jsObj的属性上\n            if (!$.isFunction(window.jsObj[methodName])) {\n                if (_this._isDebug) {\n                    _this._debugOutPut('callHandler - methodName: ' + methodName + ' 执行java方法错误,找不到该方法', _this._debugStyle._ERROR_);\n                }\n\n                throw new TypeError('执行java方法错误,找不到该方法');\n            }\n            try {\n                //TODO: 方法必须直接调用\n                message = window.jsObj[methodName](JSON.stringify(params));\n\n                //调用app方法返回的数据\n                if (_this._isDebug) {\n                    _this._debugOutPut('callHandeler reponse data: ' + JSON.stringify(message), _this._debugStyle._NORMAL_);\n                }\n\n            } catch (e) {\n                if (_this._isDebug) {\n                    console.log(e);\n                    console.log('java方法执行出错');\n                    _this._debugOutPut('callHandler: ' + methodName + ' ' + e, _this._debugStyle._ERROR_);\n                    _this._debugOutPut('callHandler: java方法执行出错 ' + methodName, _this._debugStyle._ERROR_);\n                }\n                return;\n            }\n            callback(message);\n        }\n    },\n    /**\n     * 调用本地方法\n     * @param className    required\n     * @param method    required\n     * @param params @type 数组    options\n     * @param cb @type 函数    options\n     */\n    executeNativeMethod: function(className, method, params, cb) {\n        var _this = this;\n        if (arguments.length < 2 || arguments.length > 4) {\n\n            if (_this._isDebug) {\n                _this._debugOutPut('调用参数个数应该为w-4个，分别为className,method,params以及可选的cb回调', _this._debugStyle._ERROR_);\n            }\n\n            throw new EvalError('调用参数个数应该为w-4个，分别为className,method,params以及可选的cb回调');\n        }\n        if (typeof className !== 'string') {\n\n            if (_this._isDebug) {\n                _this._debugOutPut('className类型错误', _this._debugStyle._ERROR_);\n            }\n\n            throw new TypeError('className类型错误');\n        }\n        if (typeof method !== 'string') {\n\n            if (_this._isDebug) {\n                _this._debugOutPut('method类型错误', _this._debugStyle._ERROR_);\n            }\n\n            throw new TypeError('method类型错误');\n        }\n        if (!params) {\n            params = [];\n        } else if (params && !cb && {}.toString.call(params) !== '[object Array]') {\n            if (typeof params !== 'function') {\n                throw new TypeError('params应为数组');\n            } else {\n                cb = params;\n                params = [];\n            }\n        } else if (cb) {\n            if (typeof cb !== 'function') {\n                throw new TypeError('cb类型错误');\n            }\n        }\n\n        cb && cbsAfterExecNativeMethod.push(cb);\n        var ret, fnCode, i, len, str;\n        try {\n            // 1,无法使用call，apply方式调用oc本地方法\n            // ret = window[className][method].apply(null,params);\n            // 2,无法间接调用\n            // fn ＝ window[className][method];fn();\n\n            fnCode = 'window[className][method](';\n            for (i = 0, len = params.length; i < len; i++) {\n                if (typeof params[i] == 'string') {\n                    str = \"\\'\" + params[i] + \"\\'\";\n                } else {\n                    str = params[i];\n                }\n                if (i < len - 1) {\n                    fnCode += str + ',';\n                } else {\n                    fnCode += str + ')';\n                }\n            }\n            eval(fnCode);\n\n        } catch (e) {\n            cb && cb(e);\n            cbsAfterExecNativeMethod = [];\n        }\n    },\n    /**\n     * 注册js函数，与registerHandler的区别仅仅在于iOS层实现的不同\n     * iOS抛弃使用webViewJavaScriptBridge框架，该用JSC引擎通信\n     *\n     * @param methodName 函数名\n     * @param method  method函数只接受一个对象,为native层传入的消息\n     */\n    registerJSMethod: function(methodName, method) {\n        var isiOS4JSC = $.JSBridge.isiOS4JSC;\n        if (isiOS4JSC) {\n            // 将注册的方法透出到window.jscObj的属性上\n            var ev = eval;\n            $.JSBridge._JSMethod = method;\n\n            // 暴露函数至全局\n            // jsc只能执行全局函数声明方式定义的函数，不可以将函数指针复制给其他变量执行\n            ev('function toObjectCExec() {' + 'window.jscObj = window.jscObj ? window.jscObj : {};' + 'window.jscObj[\"' + methodName + '\"] = function (message) {' + '  var ret = $.JSBridge._JSMethod(message);' + '  return JSON.stringify(ret);' + '};' + 'return jscObj;' + '}');\n\n        } else if (isAndroid) {\n            // 将注册的方法透出到window.javaObj的属性上\n            window.javaObj = window.javaObj ? window.javaObj : {};\n            window.javaObj[methodName] = function(message) {\n                var ret = method(message);\n\n                // java执行js函数不返回结果，通过url传递序列化结果\n                _createQueueReadyIframe(document, 'transfer://toAndroid/' + encodeURIComponent(JSON.stringify(ret)));\n            };\n        }\n\n    },\n    _transResultFromNative: function(ret) {\n        retFromNative = ret;\n        var cbs = cbsAfterExecNativeMethod;\n        cbsAfterExecNativeMethod = [];\n        for (var i = 0, len = cbs.length; i < len; i++) {\n            cbs[i](null, ret);\n        }\n    },\n    /**\n     * 测试环境进行debug信息的展示\n     */\n    _isDebug: false,\n    // 判断测试环境\n    _isTest: (function() {\n        if (globalConfig.Env === 'test') {\n            return true;\n        } else {\n            return false;\n        }\n    })(),\n    setDebug: function(bool) {\n        var _this = this;\n        if (bool) {\n            _this._isDebug = true;\n            if (_this._isTest) {\n                _this._debugShow();\n            }\n        } else {\n            _this._isDebug = false;\n        }\n    },\n    _debugShow: function() {\n        var _this = this;\n\n        function _debugBlockInit() {\n            var debugBlock = '<div class=\"webview-btn j_WebviewDebugBtn\">debug</div>' + '<div class=\"webview-console j_WebviewConsole\"><div class=\"pannel j_WebviewPannel\"></div></div>';\n            $('body').append(debugBlock);\n        }\n\n        function _eventBind() {\n            var $webviewConsole = $('.j_WebviewConsole');\n            $(document).on('click', '.j_WebviewDebugBtn', function() {\n                if ($webviewConsole.hasClass('show')) {\n                    $webviewConsole.removeClass('show');\n                } else {\n                    $webviewConsole.addClass('show');\n                }\n            })\n        }\n\n        function _initDebugFunction() {\n            if (isAndroid) {\n                _this._debugOutPut('env: showjoy Android app', _this._debugStyle._NORMAL_);\n            } else if (isiOS) {\n                _this._debugOutPut('env: showjoy IOS app', _this._debugStyle._NORMAL_);\n            }\n        }\n\n        if (isAndroid || isiOS) {\n            _debugBlockInit();\n            _eventBind();\n            _initDebugFunction();\n        }\n    },\n    _debugStyle: {\n        _NORMAL_: 'normal',\n        _WARNING_: 'warn',\n        _ERROR_: 'error',\n    },\n    _debugOutPut: function(content, style) {\n        if (this._isDebug) {\n            var $consolePannel = $('.j_WebviewPannel');\n            $consolePannel.append('<p class=\"' + style + '\">' + content + '</p>');\n        }\n    }\n};\n\nJSBridge._init();\n\n// 暴露方法到全局命名空间\n$.JSBridge = JSBridge; \n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/qiyuan/.spon/mobi/fecomponent/mobi-jswebview/0.0.17/index.js\n ** module id = 3\n ** module chunks = 0\n **/","//  模块外面不用包一层define，dev和build时工具会自动加上，遵循CommonJS规范，像node一样写就可以了，如下\n'use strict';\n\n$.Callbacks = function(options) {\n  options = $.extend({}, options)\n\n  var memory, // Last fire value (for non-forgettable lists)\n    fired,  // Flag to know if list was already fired\n    firing, // Flag to know if list is currently firing\n    firingStart, // First callback to fire (used internally by add and fireWith)\n    firingLength, // End of the loop when firing\n    firingIndex, // Index of currently firing callback (modified by remove if needed)\n    list = [], // Actual callback list\n    stack = !options.once && [], // Stack of fire calls for repeatable lists\n    fire = function(data) {\n      memory = options.memory && data\n      fired = true\n      firingIndex = firingStart || 0\n      firingStart = 0\n      firingLength = list.length\n      firing = true\n      for ( ; list && firingIndex < firingLength ; ++firingIndex ) {\n        if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {\n          memory = false\n          break\n        }\n      }\n      firing = false\n      if (list) {\n        if (stack) stack.length && fire(stack.shift())\n        else if (memory) list.length = 0\n        else Callbacks.disable()\n      }\n    },\n\n    Callbacks = {\n      add: function() {\n        if (list) {\n          var start = list.length,\n            add = function(args) {\n              $.each(args, function(_, arg){\n                if (typeof arg === \"function\") {\n                  if (!options.unique || !Callbacks.has(arg)) list.push(arg)\n                }\n                else if (arg && arg.length && typeof arg !== 'string') add(arg)\n              })\n            }\n          add(arguments)\n          if (firing) firingLength = list.length\n          else if (memory) {\n            firingStart = start\n            fire(memory)\n          }\n        }\n        return this\n      },\n      remove: function() {\n        if (list) {\n          $.each(arguments, function(_, arg){\n            var index\n            while ((index = $.inArray(arg, list, index)) > -1) {\n              list.splice(index, 1)\n              // Handle firing indexes\n              if (firing) {\n                if (index <= firingLength) --firingLength\n                if (index <= firingIndex) --firingIndex\n              }\n            }\n          })\n        }\n        return this\n      },\n      has: function(fn) {\n        return !!(list && (fn ? $.inArray(fn, list) > -1 : list.length))\n      },\n      empty: function() {\n        firingLength = list.length = 0\n        return this\n      },\n      disable: function() {\n        list = stack = memory = undefined\n        return this\n      },\n      disabled: function() {\n        return !list\n      },\n      lock: function() {\n        stack = undefined;\n        if (!memory) Callbacks.disable()\n        return this\n      },\n      locked: function() {\n        return !stack\n      },\n      fireWith: function(context, args) {\n        if (list && (!fired || stack)) {\n          args = args || []\n          args = [context, args.slice ? args.slice() : args]\n          if (firing) stack.push(args)\n          else fire(args)\n        }\n        return this\n      },\n      fire: function() {\n        return Callbacks.fireWith(this, arguments)\n      },\n      fired: function() {\n        return !!fired\n      }\n    }\n\n  return Callbacks\n\n}\n\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/qiyuan/.spon/mobi/fecomponent/mobi-zepto-callbacks/0.0.4/index.js\n ** module id = 4\n ** module chunks = 0\n **/","//  模块外面不用包一层define，dev和build时工具会自动加上，遵循CommonJS规范，像node一样写就可以了，如下\n\n'use strict';\n\n\nvar slice = Array.prototype.slice\n\nfunction Deferred(func) {\n  var tuples = [\n      // action, add listener, listener list, final state\n      [ \"resolve\", \"done\", $.Callbacks({once:1, memory:1}), \"resolved\" ],\n      [ \"reject\", \"fail\", $.Callbacks({once:1, memory:1}), \"rejected\" ],\n      [ \"notify\", \"progress\", $.Callbacks({memory:1}) ]\n    ],\n    state = \"pending\",\n    promise = {\n      state: function() {\n        return state\n      },\n      always: function() {\n        deferred.done(arguments).fail(arguments)\n        return this\n      },\n      then: function(/* fnDone [, fnFailed [, fnProgress]] */) {\n        var fns = arguments\n        return Deferred(function(defer){\n          $.each(tuples, function(i, tuple){\n            var fn = $.isFunction(fns[i]) && fns[i]\n            deferred[tuple[1]](function(){\n              var returned = fn && fn.apply(this, arguments)\n              if (returned && $.isFunction(returned.promise)) {\n                returned.promise()\n                  .done(defer.resolve)\n                  .fail(defer.reject)\n                  .progress(defer.notify)\n              } else {\n                var context = this === promise ? defer.promise() : this,\n                  values = fn ? [returned] : arguments\n                defer[tuple[0] + \"With\"](context, values)\n              }\n            })\n          })\n          fns = null\n        }).promise()\n      },\n\n      promise: function(obj) {\n        return obj != null ? $.extend( obj, promise ) : promise\n      }\n    },\n    deferred = {}\n\n  $.each(tuples, function(i, tuple){\n    var list = tuple[2],\n      stateString = tuple[3]\n\n    promise[tuple[1]] = list.add\n\n    if (stateString) {\n      list.add(function(){\n        state = stateString\n      }, tuples[i^1][2].disable, tuples[2][2].lock)\n    }\n\n    deferred[tuple[0]] = function(){\n      deferred[tuple[0] + \"With\"](this === deferred ? promise : this, arguments)\n      return this\n    }\n    deferred[tuple[0] + \"With\"] = list.fireWith\n  })\n\n  promise.promise(deferred)\n  if (func) func.call(deferred, deferred)\n  return deferred\n}\n\n$.when = function(sub) {\n  var resolveValues = slice.call(arguments),\n    len = resolveValues.length,\n    i = 0,\n    remain = len !== 1 || (sub && $.isFunction(sub.promise)) ? len : 0,\n    deferred = remain === 1 ? sub : Deferred(),\n    progressValues, progressContexts, resolveContexts,\n    updateFn = function(i, ctx, val){\n      return function(value){\n        ctx[i] = this\n        val[i] = arguments.length > 1 ? slice.call(arguments) : value\n        if (val === progressValues) {\n          deferred.notifyWith(ctx, val)\n        } else if (!(--remain)) {\n          deferred.resolveWith(ctx, val)\n        }\n      }\n    }\n\n  if (len > 1) {\n    progressValues = new Array(len)\n    progressContexts = new Array(len)\n    resolveContexts = new Array(len)\n    for ( ; i < len; ++i ) {\n      if (resolveValues[i] && $.isFunction(resolveValues[i].promise)) {\n        resolveValues[i].promise()\n          .done(updateFn(i, resolveContexts, resolveValues))\n          .fail(deferred.reject)\n          .progress(updateFn(i, progressContexts, progressValues))\n      } else {\n        --remain\n      }\n    }\n  }\n  if (!remain) deferred.resolveWith(resolveContexts, resolveValues)\n  return deferred.promise()\n}\n\n$.Deferred = Deferred;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/qiyuan/.spon/mobi/fecomponent/mobi-zepto-deferred/0.0.3/index.js\n ** module id = 5\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../../../../../usr/local/lib/node_modules/spon/node_modules/css-loader/index.js!./../../../../../../../usr/local/lib/node_modules/spon/node_modules/less-loader/index.js!./js-debug.less\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../../../../../usr/local/lib/node_modules/spon/node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../../../../usr/local/lib/node_modules/spon/node_modules/css-loader/index.js!./../../../../../../../usr/local/lib/node_modules/spon/node_modules/less-loader/index.js!./js-debug.less\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../../../../usr/local/lib/node_modules/spon/node_modules/css-loader/index.js!./../../../../../../../usr/local/lib/node_modules/spon/node_modules/less-loader/index.js!./js-debug.less\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/qiyuan/.spon/mobi/fecomponent/mobi-jswebview/0.0.17/js-debug.less\n ** module id = 6\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../../../../../../usr/local/lib/node_modules/spon/node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".webview-btn{position:fixed;top:55%;left:0;width:50px;height:50px;opacity:.5;background-color:#000;color:#fff;font:13px/50px Arial;border-radius:25px;text-align:center}.webview-console{display:none;position:fixed;top:0;left:0;z-index:1000;width:100%;height:200px;overflow-y:scroll;background-color:#fff;padding:10px}.webview-console .pannel{width:100%;height:auto}.webview-console .pannel p{width:100%;height:auto;margin-bottom:5px;font:13px/14px Helvetica Neue}.webview-console .pannel .normal{color:#000}.webview-console .pannel .warn{color:orange}.webview-console .pannel .error{color:red}.webview-console.show{display:block}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /usr/local/lib/~/spon/~/css-loader!/usr/local/lib/~/spon/~/less-loader!/Users/qiyuan/.spon/mobi/fecomponent/mobi-jswebview/0.0.17/js-debug.less\n ** module id = 7\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /usr/local/lib/~/spon/~/css-loader/lib/css-base.js\n ** module id = 8\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /usr/local/lib/~/spon/~/style-loader/addStyles.js\n ** module id = 9\n ** module chunks = 0\n **/"],"sourceRoot":""}